=====================Reduction starts.======================

The initial program size is 462
The command line options are:
---
helpFlags:
  groupName: "Help"
  help: false
verbosityFlags:
  groupName: "Verbosity"
  verbosity: "INFO"
  listVerbosity: false
versionFlags:
  groupName: "Version"
  version: false
inputFlags:
  groupName: "Inputs"
  testScript: "predict.sh"
  inputFile: "Test.java"
  deps: []
  sourceFile: "Test.java"
resultOutputFlags:
  groupName: "Outputs"
  outputDir: null
reductionControlFlags:
  groupName: "General Reduction Control"
  fixpoint: true
  numOfThreads: 32
  codeFormat: "COMPACT_ORIG_FORMAT"
  testScriptExecutionTimeoutInSeconds: 600
  testScriptExecutionKeepWaitingAfterTimeout: true
outputRefiningFlags:
  groupName: "Output Refining Control"
  callFormatter: false
  formatCmd: ""
  callCReduce: false
  creduceCmd: "creduce"
algorithmControlFlags:
  groupName: "Reduction Algorithm Control"
  reductionAlgorithm: null
  listAllReductionAlgorithms: false
  rebuildParseTreeEachIteration: true
  enableTokenSlicer: false
  enableTreeSlicer: false
  enableLineSlicer: false
  defaultDeltaDebuggerTypeForKleene: "DFS"
  maxEditCountForRegularRuleNode: 100
  maxBfsDepthForRegularRuleNode: 5
  stopAtFirstCompatibleChildForRegularRuleNode: false
languageControlFlags:
  groupName: "Language Control"
  languageName: ""
  listLangs: false
  designatedParserFacadeClassName: ""
  listParserFacades: false
  languageJarFiles: []
vulcanFlags:
  groupName: "Vulcan Reducer Control"
  enableVulcan: false
  nonDeletionIterationLimit: 10
  windowSize: 4
  vulcanFixpoint: false
trecFlags:
  groupName: "T-Rec Reducer Control"
  enableTrec: false
profilingFlags:
  groupName: "Profiling"
  progressDumpFile: "perses_progress.txt"
  appendToProgressDumpFile: true
  statDumpFile: null
  profileQueryCacheTime: null
  profileQueryCacheTimeCSV: null
  profileQueryCacheMemory: null
  actionSetProfiler: null
  profileDeltaDebugger: null
cacheControlFlags:
  groupName: "Cache Control"
  queryCaching: "AUTO"
  cacheType: "CONTENT_SHA512"
  nodeActionSetCaching: true
  queryCacheRefreshThreshold: 0
  enableLightweightRefreshing: true
  enablePassCache: false
  globalCacheFile: null
  pathToSaveUpdatedGlobalCache: null
experimentFlags:
  groupName: "Experiment Control"
  onDemandFineGritReducerAnnotationClasses: []
  onDemandMediumGritReducerAnnotationClasses: []
  onDemandCoarseGritReducerAnnotationClasses: []
lprFlags:
  groupName: "LPR Reducer Control"
  enableLPR: false
  lprFixpoint: false
  llmClientPath: null

Parser Facade: class org.perses.grammar.java.Java8ParserFacade
------------------------------------------------------------


The sanity check has been performed. The result is PassingSanityCheckResult
The reducer execution plan is listed below.
--- !<fixpoint>
body: !<atomic>
  reducer: perses_node_priority_with_dfs_delta
condition: smaller


Rebuilding spar-tree: The spartree is not dirty, and thus the rebuilding is skipped.

=Fixpoint iteration 1. Reducer: perses_node_priority_with_dfs_delta

The spar-tree is the following.
compilationUnit {id=1,slot_type=compilationUnit}
|___(*) {id=2,slot_type=kleene_star__compilationUnit_2}
|   |___singleTypeImportDeclaration {id=1938,slot_type=[importDeclaration,singleTypeImportDeclaration]}
|   |   |___Token:import {id=1939,slot_type=IMPORT}
|   |   |___typeName {id=1940,slot_type=typeName}
|   |   |   |___(?) {id=1942,slot_type=optional__typeName_2}
|   |   |   |   |___aux_rule__typeName_1 {id=1944,slot_type=aux_rule__typeName_1}
|   |   |   |       |___packageName {id=1945,slot_type=packageName}
|   |   |   |       |   |___Token:java {id=1947,slot_type=Identifier}
|   |   |   |       |   |___(*) {id=1948,slot_type=kleene_star__packageName_1}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1949,slot_type=aux_rule__packageName_2}
|   |   |   |       |           |___Token:. {id=1950,slot_type=DOT}
|   |   |   |       |           |___Token:util {id=1951,slot_type=Identifier}
|   |   |   |       |___Token:. {id=1946,slot_type=DOT}
|   |   |   |___Token:ArrayList {id=1943,slot_type=Identifier}
|   |   |___Token:; {id=1941,slot_type=SEMI}
|   |___singleTypeImportDeclaration {id=1924,slot_type=[importDeclaration,singleTypeImportDeclaration]}
|   |   |___Token:import {id=1925,slot_type=IMPORT}
|   |   |___typeName {id=1926,slot_type=typeName}
|   |   |   |___(?) {id=1928,slot_type=optional__typeName_2}
|   |   |   |   |___aux_rule__typeName_1 {id=1930,slot_type=aux_rule__typeName_1}
|   |   |   |       |___packageName {id=1931,slot_type=packageName}
|   |   |   |       |   |___Token:java {id=1933,slot_type=Identifier}
|   |   |   |       |   |___(*) {id=1934,slot_type=kleene_star__packageName_1}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1935,slot_type=aux_rule__packageName_2}
|   |   |   |       |           |___Token:. {id=1936,slot_type=DOT}
|   |   |   |       |           |___Token:util {id=1937,slot_type=Identifier}
|   |   |   |       |___Token:. {id=1932,slot_type=DOT}
|   |   |   |___Token:Arrays {id=1929,slot_type=Identifier}
|   |   |___Token:; {id=1927,slot_type=SEMI}
|   |___singleTypeImportDeclaration {id=1910,slot_type=[importDeclaration,singleTypeImportDeclaration]}
|   |   |___Token:import {id=1911,slot_type=IMPORT}
|   |   |___typeName {id=1912,slot_type=typeName}
|   |   |   |___(?) {id=1914,slot_type=optional__typeName_2}
|   |   |   |   |___aux_rule__typeName_1 {id=1916,slot_type=aux_rule__typeName_1}
|   |   |   |       |___packageName {id=1917,slot_type=packageName}
|   |   |   |       |   |___Token:java {id=1919,slot_type=Identifier}
|   |   |   |       |   |___(*) {id=1920,slot_type=kleene_star__packageName_1}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1921,slot_type=aux_rule__packageName_2}
|   |   |   |       |           |___Token:. {id=1922,slot_type=DOT}
|   |   |   |       |           |___Token:util {id=1923,slot_type=Identifier}
|   |   |   |       |___Token:. {id=1918,slot_type=DOT}
|   |   |   |___Token:HashMap {id=1915,slot_type=Identifier}
|   |   |___Token:; {id=1913,slot_type=SEMI}
|   |___singleTypeImportDeclaration {id=1896,slot_type=[importDeclaration,singleTypeImportDeclaration]}
|   |   |___Token:import {id=1897,slot_type=IMPORT}
|   |   |___typeName {id=1898,slot_type=typeName}
|   |   |   |___(?) {id=1900,slot_type=optional__typeName_2}
|   |   |   |   |___aux_rule__typeName_1 {id=1902,slot_type=aux_rule__typeName_1}
|   |   |   |       |___packageName {id=1903,slot_type=packageName}
|   |   |   |       |   |___Token:java {id=1905,slot_type=Identifier}
|   |   |   |       |   |___(*) {id=1906,slot_type=kleene_star__packageName_1}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1907,slot_type=aux_rule__packageName_2}
|   |   |   |       |           |___Token:. {id=1908,slot_type=DOT}
|   |   |   |       |           |___Token:util {id=1909,slot_type=Identifier}
|   |   |   |       |___Token:. {id=1904,slot_type=DOT}
|   |   |   |___Token:Map {id=1901,slot_type=Identifier}
|   |   |___Token:; {id=1899,slot_type=SEMI}
|   |___singleTypeImportDeclaration {id=1882,slot_type=[importDeclaration,singleTypeImportDeclaration]}
|   |   |___Token:import {id=1883,slot_type=IMPORT}
|   |   |___typeName {id=1884,slot_type=typeName}
|   |   |   |___(?) {id=1886,slot_type=optional__typeName_2}
|   |   |   |   |___aux_rule__typeName_1 {id=1888,slot_type=aux_rule__typeName_1}
|   |   |   |       |___packageName {id=1889,slot_type=packageName}
|   |   |   |       |   |___Token:java {id=1891,slot_type=Identifier}
|   |   |   |       |   |___(*) {id=1892,slot_type=kleene_star__packageName_1}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1893,slot_type=aux_rule__packageName_2}
|   |   |   |       |           |___Token:. {id=1894,slot_type=DOT}
|   |   |   |       |           |___Token:util {id=1895,slot_type=Identifier}
|   |   |   |       |___Token:. {id=1890,slot_type=DOT}
|   |   |   |___Token:Timer {id=1887,slot_type=Identifier}
|   |   |___Token:; {id=1885,slot_type=SEMI}
|   |___singleTypeImportDeclaration {id=1868,slot_type=[importDeclaration,singleTypeImportDeclaration]}
|   |   |___Token:import {id=1869,slot_type=IMPORT}
|   |   |___typeName {id=1870,slot_type=typeName}
|   |   |   |___(?) {id=1872,slot_type=optional__typeName_2}
|   |   |   |   |___aux_rule__typeName_1 {id=1874,slot_type=aux_rule__typeName_1}
|   |   |   |       |___packageName {id=1875,slot_type=packageName}
|   |   |   |       |   |___Token:java {id=1877,slot_type=Identifier}
|   |   |   |       |   |___(*) {id=1878,slot_type=kleene_star__packageName_1}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1879,slot_type=aux_rule__packageName_2}
|   |   |   |       |           |___Token:. {id=1880,slot_type=DOT}
|   |   |   |       |           |___Token:util {id=1881,slot_type=Identifier}
|   |   |   |       |___Token:. {id=1876,slot_type=DOT}
|   |   |   |___Token:TimerTask {id=1873,slot_type=Identifier}
|   |   |___Token:; {id=1871,slot_type=SEMI}
|   |___singleTypeImportDeclaration {id=1851,slot_type=[importDeclaration,singleTypeImportDeclaration]}
|   |   |___Token:import {id=1852,slot_type=IMPORT}
|   |   |___typeName {id=1853,slot_type=typeName}
|   |   |   |___(?) {id=1855,slot_type=optional__typeName_2}
|   |   |   |   |___aux_rule__typeName_1 {id=1857,slot_type=aux_rule__typeName_1}
|   |   |   |       |___packageName {id=1858,slot_type=packageName}
|   |   |   |       |   |___Token:java {id=1860,slot_type=Identifier}
|   |   |   |       |   |___(*) {id=1861,slot_type=kleene_star__packageName_1}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1862,slot_type=aux_rule__packageName_2}
|   |   |   |       |       |   |___Token:. {id=1866,slot_type=DOT}
|   |   |   |       |       |   |___Token:util {id=1867,slot_type=Identifier}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1863,slot_type=aux_rule__packageName_2}
|   |   |   |       |           |___Token:. {id=1864,slot_type=DOT}
|   |   |   |       |           |___Token:concurrent {id=1865,slot_type=Identifier}
|   |   |   |       |___Token:. {id=1859,slot_type=DOT}
|   |   |   |___Token:ArrayBlockingQueue {id=1856,slot_type=Identifier}
|   |   |___Token:; {id=1854,slot_type=SEMI}
|   |___singleTypeImportDeclaration {id=1834,slot_type=[importDeclaration,singleTypeImportDeclaration]}
|   |   |___Token:import {id=1835,slot_type=IMPORT}
|   |   |___typeName {id=1836,slot_type=typeName}
|   |   |   |___(?) {id=1838,slot_type=optional__typeName_2}
|   |   |   |   |___aux_rule__typeName_1 {id=1840,slot_type=aux_rule__typeName_1}
|   |   |   |       |___packageName {id=1841,slot_type=packageName}
|   |   |   |       |   |___Token:java {id=1843,slot_type=Identifier}
|   |   |   |       |   |___(*) {id=1844,slot_type=kleene_star__packageName_1}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1845,slot_type=aux_rule__packageName_2}
|   |   |   |       |       |   |___Token:. {id=1849,slot_type=DOT}
|   |   |   |       |       |   |___Token:util {id=1850,slot_type=Identifier}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1846,slot_type=aux_rule__packageName_2}
|   |   |   |       |           |___Token:. {id=1847,slot_type=DOT}
|   |   |   |       |           |___Token:concurrent {id=1848,slot_type=Identifier}
|   |   |   |       |___Token:. {id=1842,slot_type=DOT}
|   |   |   |___Token:ConcurrentHashMap {id=1839,slot_type=Identifier}
|   |   |___Token:; {id=1837,slot_type=SEMI}
|   |___singleTypeImportDeclaration {id=1817,slot_type=[importDeclaration,singleTypeImportDeclaration]}
|   |   |___Token:import {id=1818,slot_type=IMPORT}
|   |   |___typeName {id=1819,slot_type=typeName}
|   |   |   |___(?) {id=1821,slot_type=optional__typeName_2}
|   |   |   |   |___aux_rule__typeName_1 {id=1823,slot_type=aux_rule__typeName_1}
|   |   |   |       |___packageName {id=1824,slot_type=packageName}
|   |   |   |       |   |___Token:java {id=1826,slot_type=Identifier}
|   |   |   |       |   |___(*) {id=1827,slot_type=kleene_star__packageName_1}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1828,slot_type=aux_rule__packageName_2}
|   |   |   |       |       |   |___Token:. {id=1832,slot_type=DOT}
|   |   |   |       |       |   |___Token:util {id=1833,slot_type=Identifier}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1829,slot_type=aux_rule__packageName_2}
|   |   |   |       |           |___Token:. {id=1830,slot_type=DOT}
|   |   |   |       |           |___Token:concurrent {id=1831,slot_type=Identifier}
|   |   |   |       |___Token:. {id=1825,slot_type=DOT}
|   |   |   |___Token:ConcurrentLinkedQueue {id=1822,slot_type=Identifier}
|   |   |___Token:; {id=1820,slot_type=SEMI}
|   |___singleTypeImportDeclaration {id=1800,slot_type=[importDeclaration,singleTypeImportDeclaration]}
|   |   |___Token:import {id=1801,slot_type=IMPORT}
|   |   |___typeName {id=1802,slot_type=typeName}
|   |   |   |___(?) {id=1804,slot_type=optional__typeName_2}
|   |   |   |   |___aux_rule__typeName_1 {id=1806,slot_type=aux_rule__typeName_1}
|   |   |   |       |___packageName {id=1807,slot_type=packageName}
|   |   |   |       |   |___Token:java {id=1809,slot_type=Identifier}
|   |   |   |       |   |___(*) {id=1810,slot_type=kleene_star__packageName_1}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1811,slot_type=aux_rule__packageName_2}
|   |   |   |       |       |   |___Token:. {id=1815,slot_type=DOT}
|   |   |   |       |       |   |___Token:util {id=1816,slot_type=Identifier}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1812,slot_type=aux_rule__packageName_2}
|   |   |   |       |           |___Token:. {id=1813,slot_type=DOT}
|   |   |   |       |           |___Token:concurrent {id=1814,slot_type=Identifier}
|   |   |   |       |___Token:. {id=1808,slot_type=DOT}
|   |   |   |___Token:ThreadPoolExecutor {id=1805,slot_type=Identifier}
|   |   |___Token:; {id=1803,slot_type=SEMI}
|   |___singleTypeImportDeclaration {id=1783,slot_type=[importDeclaration,singleTypeImportDeclaration]}
|   |   |___Token:import {id=1784,slot_type=IMPORT}
|   |   |___typeName {id=1785,slot_type=typeName}
|   |   |   |___(?) {id=1787,slot_type=optional__typeName_2}
|   |   |   |   |___aux_rule__typeName_1 {id=1789,slot_type=aux_rule__typeName_1}
|   |   |   |       |___packageName {id=1790,slot_type=packageName}
|   |   |   |       |   |___Token:java {id=1792,slot_type=Identifier}
|   |   |   |       |   |___(*) {id=1793,slot_type=kleene_star__packageName_1}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1794,slot_type=aux_rule__packageName_2}
|   |   |   |       |       |   |___Token:. {id=1798,slot_type=DOT}
|   |   |   |       |       |   |___Token:util {id=1799,slot_type=Identifier}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1795,slot_type=aux_rule__packageName_2}
|   |   |   |       |           |___Token:. {id=1796,slot_type=DOT}
|   |   |   |       |           |___Token:concurrent {id=1797,slot_type=Identifier}
|   |   |   |       |___Token:. {id=1791,slot_type=DOT}
|   |   |   |___Token:TimeUnit {id=1788,slot_type=Identifier}
|   |   |___Token:; {id=1786,slot_type=SEMI}
|   |___singleTypeImportDeclaration {id=1763,slot_type=[importDeclaration,singleTypeImportDeclaration]}
|   |   |___Token:import {id=1764,slot_type=IMPORT}
|   |   |___typeName {id=1765,slot_type=typeName}
|   |   |   |___(?) {id=1767,slot_type=optional__typeName_2}
|   |   |   |   |___aux_rule__typeName_1 {id=1769,slot_type=aux_rule__typeName_1}
|   |   |   |       |___packageName {id=1770,slot_type=packageName}
|   |   |   |       |   |___Token:java {id=1772,slot_type=Identifier}
|   |   |   |       |   |___(*) {id=1773,slot_type=kleene_star__packageName_1}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1774,slot_type=aux_rule__packageName_2}
|   |   |   |       |       |   |___Token:. {id=1781,slot_type=DOT}
|   |   |   |       |       |   |___Token:util {id=1782,slot_type=Identifier}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1775,slot_type=aux_rule__packageName_2}
|   |   |   |       |       |   |___Token:. {id=1779,slot_type=DOT}
|   |   |   |       |       |   |___Token:concurrent {id=1780,slot_type=Identifier}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1776,slot_type=aux_rule__packageName_2}
|   |   |   |       |           |___Token:. {id=1777,slot_type=DOT}
|   |   |   |       |           |___Token:atomic {id=1778,slot_type=Identifier}
|   |   |   |       |___Token:. {id=1771,slot_type=DOT}
|   |   |   |___Token:AtomicBoolean {id=1768,slot_type=Identifier}
|   |   |___Token:; {id=1766,slot_type=SEMI}
|   |___singleTypeImportDeclaration {id=1743,slot_type=[importDeclaration,singleTypeImportDeclaration]}
|   |   |___Token:import {id=1744,slot_type=IMPORT}
|   |   |___typeName {id=1745,slot_type=typeName}
|   |   |   |___(?) {id=1747,slot_type=optional__typeName_2}
|   |   |   |   |___aux_rule__typeName_1 {id=1749,slot_type=aux_rule__typeName_1}
|   |   |   |       |___packageName {id=1750,slot_type=packageName}
|   |   |   |       |   |___Token:java {id=1752,slot_type=Identifier}
|   |   |   |       |   |___(*) {id=1753,slot_type=kleene_star__packageName_1}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1754,slot_type=aux_rule__packageName_2}
|   |   |   |       |       |   |___Token:. {id=1761,slot_type=DOT}
|   |   |   |       |       |   |___Token:util {id=1762,slot_type=Identifier}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1755,slot_type=aux_rule__packageName_2}
|   |   |   |       |       |   |___Token:. {id=1759,slot_type=DOT}
|   |   |   |       |       |   |___Token:concurrent {id=1760,slot_type=Identifier}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1756,slot_type=aux_rule__packageName_2}
|   |   |   |       |           |___Token:. {id=1757,slot_type=DOT}
|   |   |   |       |           |___Token:atomic {id=1758,slot_type=Identifier}
|   |   |   |       |___Token:. {id=1751,slot_type=DOT}
|   |   |   |___Token:AtomicLong {id=1748,slot_type=Identifier}
|   |   |___Token:; {id=1746,slot_type=SEMI}
|   |___singleTypeImportDeclaration {id=1723,slot_type=[importDeclaration,singleTypeImportDeclaration]}
|   |   |___Token:import {id=1724,slot_type=IMPORT}
|   |   |___typeName {id=1725,slot_type=typeName}
|   |   |   |___(?) {id=1727,slot_type=optional__typeName_2}
|   |   |   |   |___aux_rule__typeName_1 {id=1729,slot_type=aux_rule__typeName_1}
|   |   |   |       |___packageName {id=1730,slot_type=packageName}
|   |   |   |       |   |___Token:java {id=1732,slot_type=Identifier}
|   |   |   |       |   |___(*) {id=1733,slot_type=kleene_star__packageName_1}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1734,slot_type=aux_rule__packageName_2}
|   |   |   |       |       |   |___Token:. {id=1741,slot_type=DOT}
|   |   |   |       |       |   |___Token:util {id=1742,slot_type=Identifier}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1735,slot_type=aux_rule__packageName_2}
|   |   |   |       |       |   |___Token:. {id=1739,slot_type=DOT}
|   |   |   |       |       |   |___Token:concurrent {id=1740,slot_type=Identifier}
|   |   |   |       |       |___aux_rule__packageName_2 {id=1736,slot_type=aux_rule__packageName_2}
|   |   |   |       |           |___Token:. {id=1737,slot_type=DOT}
|   |   |   |       |           |___Token:atomic {id=1738,slot_type=Identifier}
|   |   |   |       |___Token:. {id=1731,slot_type=DOT}
|   |   |   |___Token:AtomicReference {id=1728,slot_type=Identifier}
|   |   |___Token:; {id=1726,slot_type=SEMI}
|   |___singleTypeImportDeclaration {id=1703,slot_type=[importDeclaration,singleTypeImportDeclaration]}
|       |___Token:import {id=1704,slot_type=IMPORT}
|       |___typeName {id=1705,slot_type=typeName}
|       |   |___(?) {id=1707,slot_type=optional__typeName_2}
|       |   |   |___aux_rule__typeName_1 {id=1709,slot_type=aux_rule__typeName_1}
|       |   |       |___packageName {id=1710,slot_type=packageName}
|       |   |       |   |___Token:java {id=1712,slot_type=Identifier}
|       |   |       |   |___(*) {id=1713,slot_type=kleene_star__packageName_1}
|       |   |       |       |___aux_rule__packageName_2 {id=1714,slot_type=aux_rule__packageName_2}
|       |   |       |       |   |___Token:. {id=1721,slot_type=DOT}
|       |   |       |       |   |___Token:util {id=1722,slot_type=Identifier}
|       |   |       |       |___aux_rule__packageName_2 {id=1715,slot_type=aux_rule__packageName_2}
|       |   |       |       |   |___Token:. {id=1719,slot_type=DOT}
|       |   |       |       |   |___Token:concurrent {id=1720,slot_type=Identifier}
|       |   |       |       |___aux_rule__packageName_2 {id=1716,slot_type=aux_rule__packageName_2}
|       |   |       |           |___Token:. {id=1717,slot_type=DOT}
|       |   |       |           |___Token:locks {id=1718,slot_type=Identifier}
|       |   |       |___Token:. {id=1711,slot_type=DOT}
|       |   |___Token:ReentrantLock {id=1708,slot_type=Identifier}
|       |___Token:; {id=1706,slot_type=SEMI}
|___(*) {id=3,slot_type=kleene_star__compilationUnit_3}
    |___normalClassDeclaration {id=6,slot_type=[typeDeclaration,classDeclaration,normalClassDeclaration]}
        |___(*) {id=7,slot_type=kleene_star__normalClassDeclaration_1}
        |   |___Token:public {id=1687,slot_type=[classModifier,PUBLIC]}
        |___Token:class {id=8,slot_type=CLASS}
        |___Token:Test {id=9,slot_type=Identifier}
        |___classBody {id=10,slot_type=classBody}
            |___Token:{ {id=11,slot_type=LBRACE}
            |___(*) {id=12,slot_type=kleene_star__classBody_1}
            |   |___fieldDeclaration {id=1638,slot_type=[classBodyDeclaration,fieldDeclaration]}
            |   |   |___(*) {id=1639,slot_type=kleene_star__fieldDeclaration_1}
            |   |   |   |___Token:private {id=1685,slot_type=[fieldModifier,PRIVATE]}
            |   |   |   |___Token:static {id=1684,slot_type=[fieldModifier,STATIC]}
            |   |   |   |___Token:final {id=1683,slot_type=[fieldModifier,FINAL]}
            |   |   |___Token:FlusherPool {id=1679,slot_type=[unannType,unannClassOrInterfaceType,altnt_block__unannClassOrInterfaceType_3,unannClassType_lfno_unannClassOrInterfaceType,Identifier]}
            |   |   |___variableDeclarator {id=1643,slot_type=[variableDeclaratorList,variableDeclarator]}
            |   |   |   |___Token:FLUSHER {id=1675,slot_type=[variableDeclaratorId,Identifier]}
            |   |   |   |___(?) {id=1645,slot_type=optional__variableDeclarator_2}
            |   |   |       |___aux_rule__variableDeclarator_1 {id=1646,slot_type=aux_rule__variableDeclarator_1}
            |   |   |           |___Token:= {id=1647,slot_type=ASSIGN}
            |   |   |           |___classInstanceCreationExpression_lfno_primary {id=1668,slot_type=[variableInitializer,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,classInstanceCreationExpression_lfno_primary]}
            |   |   |               |___aux_rule__classInstanceCreationExpression_lfno_primary_15 {id=1672,slot_type=[altnt_block__classInstanceCreationExpression_lfno_primary_14,aux_rule__classInstanceCreationExpression_lfno_primary_15]}
            |   |   |               |   |___Token:new {id=1673,slot_type=NEW}
            |   |   |               |   |___Token:FlusherPool {id=1674,slot_type=Identifier}
            |   |   |               |___Token:( {id=1670,slot_type=LPAREN}
            |   |   |               |___Token:) {id=1671,slot_type=RPAREN}
            |   |   |___Token:; {id=1642,slot_type=SEMI}
            |   |___normalClassDeclaration {id=52,slot_type=[classBodyDeclaration,classDeclaration,normalClassDeclaration]}
            |   |   |___(*) {id=53,slot_type=kleene_star__normalClassDeclaration_1}
            |   |   |   |___Token:private {id=1637,slot_type=[classModifier,PRIVATE]}
            |   |   |   |___Token:static {id=1636,slot_type=[classModifier,STATIC]}
            |   |   |___Token:class {id=54,slot_type=CLASS}
            |   |   |___Token:FlusherPool {id=55,slot_type=Identifier}
            |   |   |___classBody {id=56,slot_type=classBody}
            |   |       |___Token:{ {id=57,slot_type=LBRACE}
            |   |       |___(*) {id=58,slot_type=kleene_star__classBody_1}
            |   |       |   |___fieldDeclaration {id=1543,slot_type=[classBodyDeclaration,fieldDeclaration]}
            |   |       |   |   |___(*) {id=1544,slot_type=kleene_star__fieldDeclaration_1}
            |   |       |   |   |   |___Token:private {id=1633,slot_type=[fieldModifier,PRIVATE]}
            |   |       |   |   |___Token:Timer {id=1631,slot_type=[unannType,unannClassOrInterfaceType,altnt_block__unannClassOrInterfaceType_3,unannClassType_lfno_unannClassOrInterfaceType,Identifier]}
            |   |       |   |   |___variableDeclarator {id=1548,slot_type=[variableDeclaratorList,variableDeclarator]}
            |   |       |   |   |   |___Token:_timer {id=1627,slot_type=[variableDeclaratorId,Identifier]}
            |   |       |   |   |   |___(?) {id=1550,slot_type=optional__variableDeclarator_2}
            |   |       |   |   |       |___aux_rule__variableDeclarator_1 {id=1551,slot_type=aux_rule__variableDeclarator_1}
            |   |       |   |   |           |___Token:= {id=1552,slot_type=ASSIGN}
            |   |       |   |   |           |___classInstanceCreationExpression_lfno_primary {id=1573,slot_type=[variableInitializer,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,classInstanceCreationExpression_lfno_primary]}
            |   |       |   |   |               |___aux_rule__classInstanceCreationExpression_lfno_primary_15 {id=1624,slot_type=[altnt_block__classInstanceCreationExpression_lfno_primary_14,aux_rule__classInstanceCreationExpression_lfno_primary_15]}
            |   |       |   |   |               |   |___Token:new {id=1625,slot_type=NEW}
            |   |       |   |   |               |   |___Token:Timer {id=1626,slot_type=Identifier}
            |   |       |   |   |               |___Token:( {id=1575,slot_type=LPAREN}
            |   |       |   |   |               |___(?) {id=1576,slot_type=optional__explicitConstructorInvocation_2}
            |   |       |   |   |               |   |___argumentList {id=1578,slot_type=argumentList}
            |   |       |   |   |               |       |___Token:"disruptor-flush-trigger" {id=1623,slot_type=[expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,literal,StringLiteral]}
            |   |       |   |   |               |       |___(*) {id=1580,slot_type=kleene_star__argumentList_2}
            |   |       |   |   |               |           |___aux_rule__argumentList_1 {id=1581,slot_type=aux_rule__argumentList_1}
            |   |       |   |   |               |               |___Token:, {id=1582,slot_type=COMMA}
            |   |       |   |   |               |               |___Token:true {id=1603,slot_type=[expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,literal,BooleanLiteral]}
            |   |       |   |   |               |___Token:) {id=1577,slot_type=RPAREN}
            |   |       |   |   |___Token:; {id=1547,slot_type=SEMI}
            |   |       |   |___fieldDeclaration {id=1308,slot_type=[classBodyDeclaration,fieldDeclaration]}
            |   |       |   |   |___(*) {id=1309,slot_type=kleene_star__fieldDeclaration_1}
            |   |       |   |   |   |___Token:private {id=1542,slot_type=[fieldModifier,PRIVATE]}
            |   |       |   |   |___Token:ThreadPoolExecutor {id=1540,slot_type=[unannType,unannClassOrInterfaceType,altnt_block__unannClassOrInterfaceType_3,unannClassType_lfno_unannClassOrInterfaceType,Identifier]}
            |   |       |   |   |___variableDeclarator {id=1313,slot_type=[variableDeclaratorList,variableDeclarator]}
            |   |       |   |   |   |___Token:_exec {id=1536,slot_type=[variableDeclaratorId,Identifier]}
            |   |       |   |   |   |___(?) {id=1315,slot_type=optional__variableDeclarator_2}
            |   |       |   |   |       |___aux_rule__variableDeclarator_1 {id=1316,slot_type=aux_rule__variableDeclarator_1}
            |   |       |   |   |           |___Token:= {id=1317,slot_type=ASSIGN}
            |   |       |   |   |           |___classInstanceCreationExpression_lfno_primary {id=1338,slot_type=[variableInitializer,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,classInstanceCreationExpression_lfno_primary]}
            |   |       |   |   |               |___aux_rule__classInstanceCreationExpression_lfno_primary_15 {id=1533,slot_type=[altnt_block__classInstanceCreationExpression_lfno_primary_14,aux_rule__classInstanceCreationExpression_lfno_primary_15]}
            |   |       |   |   |               |   |___Token:new {id=1534,slot_type=NEW}
            |   |       |   |   |               |   |___Token:ThreadPoolExecutor {id=1535,slot_type=Identifier}
            |   |       |   |   |               |___Token:( {id=1340,slot_type=LPAREN}
            |   |       |   |   |               |___(?) {id=1341,slot_type=optional__explicitConstructorInvocation_2}
            |   |       |   |   |               |   |___argumentList {id=1343,slot_type=argumentList}
            |   |       |   |   |               |       |___Token:1 {id=1532,slot_type=[expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,literal,IntegerLiteral]}
            |   |       |   |   |               |       |___(*) {id=1345,slot_type=kleene_star__argumentList_2}
            |   |       |   |   |               |           |___aux_rule__argumentList_1 {id=1346,slot_type=aux_rule__argumentList_1}
            |   |       |   |   |               |           |   |___Token:, {id=1491,slot_type=COMMA}
            |   |       |   |   |               |           |   |___Token:100 {id=1512,slot_type=[expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,literal,IntegerLiteral]}
            |   |       |   |   |               |           |___aux_rule__argumentList_1 {id=1347,slot_type=aux_rule__argumentList_1}
            |   |       |   |   |               |           |   |___Token:, {id=1469,slot_type=COMMA}
            |   |       |   |   |               |           |   |___Token:10 {id=1490,slot_type=[expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,literal,IntegerLiteral]}
            |   |       |   |   |               |           |___aux_rule__argumentList_1 {id=1348,slot_type=aux_rule__argumentList_1}
            |   |       |   |   |               |           |   |___Token:, {id=1444,slot_type=COMMA}
            |   |       |   |   |               |           |   |___typeName {id=1462,slot_type=[expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,typeName]}
            |   |       |   |   |               |           |       |___(?) {id=1463,slot_type=optional__typeName_2}
            |   |       |   |   |               |           |       |   |___aux_rule__typeName_1 {id=1465,slot_type=aux_rule__typeName_1}
            |   |       |   |   |               |           |       |       |___Token:TimeUnit {id=1468,slot_type=[packageName,Identifier]}
            |   |       |   |   |               |           |       |       |___Token:. {id=1467,slot_type=DOT}
            |   |       |   |   |               |           |       |___Token:SECONDS {id=1464,slot_type=Identifier}
            |   |       |   |   |               |           |___aux_rule__argumentList_1 {id=1349,slot_type=aux_rule__argumentList_1}
            |   |       |   |   |               |           |   |___Token:, {id=1382,slot_type=COMMA}
            |   |       |   |   |               |           |   |___classInstanceCreationExpression_lfno_primary {id=1402,slot_type=[expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,classInstanceCreationExpression_lfno_primary]}
            |   |       |   |   |               |           |       |___aux_rule__classInstanceCreationExpression_lfno_primary_15 {id=1441,slot_type=[altnt_block__classInstanceCreationExpression_lfno_primary_14,aux_rule__classInstanceCreationExpression_lfno_primary_15]}
            |   |       |   |   |               |           |       |   |___Token:new {id=1442,slot_type=NEW}
            |   |       |   |   |               |           |       |   |___Token:ArrayBlockingQueue {id=1443,slot_type=Identifier}
            |   |       |   |   |               |           |       |___(?) {id=1404,slot_type=optional__classInstanceCreationExpression_6}
            |   |       |   |   |               |           |       |   |___typeArguments {id=1431,slot_type=[typeArgumentsOrDiamond,typeArguments]}
            |   |       |   |   |               |           |       |       |___Token:< {id=1432,slot_type=LT}
            |   |       |   |   |               |           |       |       |___Token:Runnable {id=1440,slot_type=[typeArgumentList,typeArgument,referenceType,classOrInterfaceType,altnt_block__classOrInterfaceType_3,classType_lfno_classOrInterfaceType,Identifier]}
            |   |       |   |   |               |           |       |       |___Token:> {id=1434,slot_type=GT}
            |   |       |   |   |               |           |       |___Token:( {id=1405,slot_type=LPAREN}
            |   |       |   |   |               |           |       |___(?) {id=1406,slot_type=optional__explicitConstructorInvocation_2}
            |   |       |   |   |               |           |       |   |___Token:1024 {id=1429,slot_type=[argumentList,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,literal,IntegerLiteral]}
            |   |       |   |   |               |           |       |___Token:) {id=1407,slot_type=RPAREN}
            |   |       |   |   |               |           |___aux_rule__argumentList_1 {id=1350,slot_type=aux_rule__argumentList_1}
            |   |       |   |   |               |               |___Token:, {id=1351,slot_type=COMMA}
            |   |       |   |   |               |               |___classInstanceCreationExpression_lfno_primary {id=1371,slot_type=[expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,classInstanceCreationExpression_lfno_primary]}
            |   |       |   |   |               |                   |___aux_rule__classInstanceCreationExpression_lfno_primary_15 {id=1375,slot_type=[altnt_block__classInstanceCreationExpression_lfno_primary_14,aux_rule__classInstanceCreationExpression_lfno_primary_15]}
            |   |       |   |   |               |                   |   |___Token:new {id=1376,slot_type=NEW}
            |   |       |   |   |               |                   |   |___Token:ThreadPoolExecutor {id=1377,slot_type=Identifier}
            |   |       |   |   |               |                   |   |___(*) {id=1378,slot_type=kleene_star__classInstanceCreationExpression_5}
            |   |       |   |   |               |                   |       |___aux_rule__classInstanceCreationExpression_4 {id=1379,slot_type=aux_rule__classInstanceCreationExpression_4}
            |   |       |   |   |               |                   |           |___Token:. {id=1380,slot_type=DOT}
            |   |       |   |   |               |                   |           |___Token:DiscardPolicy {id=1381,slot_type=Identifier}
            |   |       |   |   |               |                   |___Token:( {id=1373,slot_type=LPAREN}
            |   |       |   |   |               |                   |___Token:) {id=1374,slot_type=RPAREN}
            |   |       |   |   |               |___Token:) {id=1342,slot_type=RPAREN}
            |   |       |   |   |___Token:; {id=1312,slot_type=SEMI}
            |   |       |   |___fieldDeclaration {id=1228,slot_type=[classBodyDeclaration,fieldDeclaration]}
            |   |       |   |   |___(*) {id=1229,slot_type=kleene_star__fieldDeclaration_1}
            |   |       |   |   |   |___Token:private {id=1307,slot_type=[fieldModifier,PRIVATE]}
            |   |       |   |   |___unannClassType_lfno_unannClassOrInterfaceType {id=1273,slot_type=[unannType,unannClassOrInterfaceType,altnt_block__unannClassOrInterfaceType_3,unannClassType_lfno_unannClassOrInterfaceType]}
            |   |       |   |   |   |___Token:HashMap {id=1274,slot_type=Identifier}
            |   |       |   |   |   |___(?) {id=1275,slot_type=optional__classType_lfno_classOrInterfaceType_2}
            |   |       |   |   |       |___typeArguments {id=1276,slot_type=typeArguments}
            |   |       |   |   |           |___Token:< {id=1277,slot_type=LT}
            |   |       |   |   |           |___typeArgumentList {id=1278,slot_type=typeArgumentList}
            |   |       |   |   |           |   |___Token:Long {id=1305,slot_type=[typeArgument,referenceType,classOrInterfaceType,altnt_block__classOrInterfaceType_3,classType_lfno_classOrInterfaceType,Identifier]}
            |   |       |   |   |           |   |___(*) {id=1281,slot_type=kleene_star__typeArgumentList_2}
            |   |       |   |   |           |       |___aux_rule__typeArgumentList_1 {id=1282,slot_type=aux_rule__typeArgumentList_1}
            |   |       |   |   |           |           |___Token:, {id=1283,slot_type=COMMA}
            |   |       |   |   |           |           |___classType_lfno_classOrInterfaceType {id=1288,slot_type=[typeArgument,referenceType,classOrInterfaceType,altnt_block__classOrInterfaceType_3,classType_lfno_classOrInterfaceType]}
            |   |       |   |   |           |               |___Token:ArrayList {id=1289,slot_type=Identifier}
            |   |       |   |   |           |               |___(?) {id=1290,slot_type=optional__classType_lfno_classOrInterfaceType_2}
            |   |       |   |   |           |                   |___typeArguments {id=1291,slot_type=typeArguments}
            |   |       |   |   |           |                       |___Token:< {id=1292,slot_type=LT}
            |   |       |   |   |           |                       |___Token:Flusher {id=1300,slot_type=[typeArgumentList,typeArgument,referenceType,classOrInterfaceType,altnt_block__classOrInterfaceType_3,classType_lfno_classOrInterfaceType,Identifier]}
            |   |       |   |   |           |                       |___Token:> {id=1294,slot_type=GT}
            |   |       |   |   |           |___Token:> {id=1279,slot_type=GT}
            |   |       |   |   |___variableDeclarator {id=1233,slot_type=[variableDeclaratorList,variableDeclarator]}
            |   |       |   |   |   |___Token:_pendingFlush {id=1270,slot_type=[variableDeclaratorId,Identifier]}
            |   |       |   |   |   |___(?) {id=1235,slot_type=optional__variableDeclarator_2}
            |   |       |   |   |       |___aux_rule__variableDeclarator_1 {id=1236,slot_type=aux_rule__variableDeclarator_1}
            |   |       |   |   |           |___Token:= {id=1237,slot_type=ASSIGN}
            |   |       |   |   |           |___classInstanceCreationExpression_lfno_primary {id=1258,slot_type=[variableInitializer,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,classInstanceCreationExpression_lfno_primary]}
            |   |       |   |   |               |___aux_rule__classInstanceCreationExpression_lfno_primary_15 {id=1267,slot_type=[altnt_block__classInstanceCreationExpression_lfno_primary_14,aux_rule__classInstanceCreationExpression_lfno_primary_15]}
            |   |       |   |   |               |   |___Token:new {id=1268,slot_type=NEW}
            |   |       |   |   |               |   |___Token:HashMap {id=1269,slot_type=Identifier}
            |   |       |   |   |               |___(?) {id=1260,slot_type=optional__classInstanceCreationExpression_6}
            |   |       |   |   |               |   |___aux_rule__typeArgumentsOrDiamond_1 {id=1264,slot_type=[typeArgumentsOrDiamond,aux_rule__typeArgumentsOrDiamond_1]}
            |   |       |   |   |               |       |___Token:< {id=1265,slot_type=LT}
            |   |       |   |   |               |       |___Token:> {id=1266,slot_type=GT}
            |   |       |   |   |               |___Token:( {id=1261,slot_type=LPAREN}
            |   |       |   |   |               |___Token:) {id=1262,slot_type=RPAREN}
            |   |       |   |   |___Token:; {id=1232,slot_type=SEMI}
            |   |       |   |___fieldDeclaration {id=1159,slot_type=[classBodyDeclaration,fieldDeclaration]}
            |   |       |   |   |___(*) {id=1160,slot_type=kleene_star__fieldDeclaration_1}
            |   |       |   |   |   |___Token:private {id=1227,slot_type=[fieldModifier,PRIVATE]}
            |   |       |   |   |___unannClassType_lfno_unannClassOrInterfaceType {id=1204,slot_type=[unannType,unannClassOrInterfaceType,altnt_block__unannClassOrInterfaceType_3,unannClassType_lfno_unannClassOrInterfaceType]}
            |   |       |   |   |   |___Token:HashMap {id=1205,slot_type=Identifier}
            |   |       |   |   |   |___(?) {id=1206,slot_type=optional__classType_lfno_classOrInterfaceType_2}
            |   |       |   |   |       |___typeArguments {id=1207,slot_type=typeArguments}
            |   |       |   |   |           |___Token:< {id=1208,slot_type=LT}
            |   |       |   |   |           |___typeArgumentList {id=1209,slot_type=typeArgumentList}
            |   |       |   |   |           |   |___Token:Long {id=1225,slot_type=[typeArgument,referenceType,classOrInterfaceType,altnt_block__classOrInterfaceType_3,classType_lfno_classOrInterfaceType,Identifier]}
            |   |       |   |   |           |   |___(*) {id=1212,slot_type=kleene_star__typeArgumentList_2}
            |   |       |   |   |           |       |___aux_rule__typeArgumentList_1 {id=1213,slot_type=aux_rule__typeArgumentList_1}
            |   |       |   |   |           |           |___Token:, {id=1214,slot_type=COMMA}
            |   |       |   |   |           |           |___Token:TimerTask {id=1220,slot_type=[typeArgument,referenceType,classOrInterfaceType,altnt_block__classOrInterfaceType_3,classType_lfno_classOrInterfaceType,Identifier]}
            |   |       |   |   |           |___Token:> {id=1210,slot_type=GT}
            |   |       |   |   |___variableDeclarator {id=1164,slot_type=[variableDeclaratorList,variableDeclarator]}
            |   |       |   |   |   |___Token:_tt {id=1201,slot_type=[variableDeclaratorId,Identifier]}
            |   |       |   |   |   |___(?) {id=1166,slot_type=optional__variableDeclarator_2}
            |   |       |   |   |       |___aux_rule__variableDeclarator_1 {id=1167,slot_type=aux_rule__variableDeclarator_1}
            |   |       |   |   |           |___Token:= {id=1168,slot_type=ASSIGN}
            |   |       |   |   |           |___classInstanceCreationExpression_lfno_primary {id=1189,slot_type=[variableInitializer,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,classInstanceCreationExpression_lfno_primary]}
            |   |       |   |   |               |___aux_rule__classInstanceCreationExpression_lfno_primary_15 {id=1198,slot_type=[altnt_block__classInstanceCreationExpression_lfno_primary_14,aux_rule__classInstanceCreationExpression_lfno_primary_15]}
            |   |       |   |   |               |   |___Token:new {id=1199,slot_type=NEW}
            |   |       |   |   |               |   |___Token:HashMap {id=1200,slot_type=Identifier}
            |   |       |   |   |               |___(?) {id=1191,slot_type=optional__classInstanceCreationExpression_6}
            |   |       |   |   |               |   |___aux_rule__typeArgumentsOrDiamond_1 {id=1195,slot_type=[typeArgumentsOrDiamond,aux_rule__typeArgumentsOrDiamond_1]}
            |   |       |   |   |               |       |___Token:< {id=1196,slot_type=LT}
            |   |       |   |   |               |       |___Token:> {id=1197,slot_type=GT}
            |   |       |   |   |               |___Token:( {id=1192,slot_type=LPAREN}
            |   |       |   |   |               |___Token:) {id=1193,slot_type=RPAREN}
            |   |       |   |   |___Token:; {id=1163,slot_type=SEMI}
            |   |       |   |___methodDeclaration {id=602,slot_type=[classBodyDeclaration,methodDeclaration]}
            |   |       |   |   |___(*) {id=603,slot_type=kleene_star__methodDeclaration_1}
            |   |       |   |   |   |___Token:public {id=1158,slot_type=[methodModifier,PUBLIC]}
            |   |       |   |   |   |___Token:synchronized {id=1157,slot_type=[methodModifier,SYNCHRONIZED]}
            |   |       |   |   |___methodHeader {id=604,slot_type=methodHeader}
            |   |       |   |   |   |___Token:void {id=1154,slot_type=[result,VOID]}
            |   |       |   |   |   |___methodDeclarator {id=1124,slot_type=methodDeclarator}
            |   |       |   |   |       |___Token:start {id=1125,slot_type=Identifier}
            |   |       |   |   |       |___Token:( {id=1126,slot_type=LPAREN}
            |   |       |   |   |       |___(?) {id=1127,slot_type=optional__methodDeclarator_1}
            |   |       |   |   |       |   |___aux_rule__formalParameterList_3 {id=1130,slot_type=[formalParameterList,aux_rule__formalParameterList_3]}
            |   |       |   |   |       |       |___(?) {id=1131,slot_type=optional__formalParameterList_2}
            |   |       |   |   |       |       |   |___aux_rule__formalParameterList_1 {id=1142,slot_type=aux_rule__formalParameterList_1}
            |   |       |   |   |       |       |       |___formalParameter {id=1146,slot_type=[formalParameters,altnt_block__formalParameters_5,formalParameter]}
            |   |       |   |   |       |       |       |   |___Token:Flusher {id=1153,slot_type=[unannType,unannClassOrInterfaceType,altnt_block__unannClassOrInterfaceType_3,unannClassType_lfno_unannClassOrInterfaceType,Identifier]}
            |   |       |   |   |       |       |       |   |___Token:flusher {id=1149,slot_type=[variableDeclaratorId,Identifier]}
            |   |       |   |   |       |       |       |___Token:, {id=1144,slot_type=COMMA}
            |   |       |   |   |       |       |___formalParameter {id=1133,slot_type=[lastFormalParameter,formalParameter]}
            |   |       |   |   |       |           |___(*) {id=1134,slot_type=kleene_star__lastFormalParameter_1}
            |   |       |   |   |       |           |   |___Token:final {id=1141,slot_type=[variableModifier,FINAL]}
            |   |       |   |   |       |           |___Token:long {id=1139,slot_type=[unannType,altnt_block__primitiveType_3,LONG]}
            |   |       |   |   |       |           |___Token:flushInterval {id=1137,slot_type=[variableDeclaratorId,Identifier]}
            |   |       |   |   |       |___Token:) {id=1128,slot_type=RPAREN}
            |   |       |   |   |___block {id=606,slot_type=[methodBody,block]}
            |   |       |   |       |___Token:{ {id=607,slot_type=LBRACE}
            |   |       |   |       |___(?) {id=608,slot_type=optional__block_1}
            |   |       |   |       |   |___(+) {id=610,slot_type=blockStatements}
            |   |       |   |       |       |___localVariableDeclarationStatement {id=1046,slot_type=[blockStatement,localVariableDeclarationStatement]}
            |   |       |   |       |       |   |___localVariableDeclaration {id=1047,slot_type=localVariableDeclaration}
            |   |       |   |       |       |   |   |___unannClassType_lfno_unannClassOrInterfaceType {id=1110,slot_type=[unannType,unannClassOrInterfaceType,altnt_block__unannClassOrInterfaceType_3,unannClassType_lfno_unannClassOrInterfaceType]}
            |   |       |   |       |       |   |   |   |___Token:ArrayList {id=1111,slot_type=Identifier}
            |   |       |   |       |       |   |   |   |___(?) {id=1112,slot_type=optional__classType_lfno_classOrInterfaceType_2}
            |   |       |   |       |       |   |   |       |___typeArguments {id=1113,slot_type=typeArguments}
            |   |       |   |       |       |   |   |           |___Token:< {id=1114,slot_type=LT}
            |   |       |   |       |       |   |   |           |___Token:Flusher {id=1122,slot_type=[typeArgumentList,typeArgument,referenceType,classOrInterfaceType,altnt_block__classOrInterfaceType_3,classType_lfno_classOrInterfaceType,Identifier]}
            |   |       |   |       |       |   |   |           |___Token:> {id=1116,slot_type=GT}
            |   |       |   |       |       |   |   |___variableDeclarator {id=1051,slot_type=[variableDeclaratorList,variableDeclarator]}
            |   |       |   |       |       |   |       |___Token:pending {id=1107,slot_type=[variableDeclaratorId,Identifier]}
            |   |       |   |       |       |   |       |___(?) {id=1053,slot_type=optional__variableDeclarator_2}
            |   |       |   |       |       |   |           |___aux_rule__variableDeclarator_1 {id=1054,slot_type=aux_rule__variableDeclarator_1}
            |   |       |   |       |       |   |               |___Token:= {id=1055,slot_type=ASSIGN}
            |   |       |   |       |       |   |               |___methodInvocation_lfno_primary {id=1076,slot_type=[variableInitializer,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,methodInvocation_lfno_primary]}
            |   |       |   |       |       |   |                   |___aux_rule__methodInvocation_lfno_primary_14 {id=1079,slot_type=[altnt_block__methodInvocation_lfno_primary_10,aux_rule__methodInvocation_lfno_primary_14]}
            |   |       |   |       |       |   |                   |   |___Token:_pendingFlush {id=1106,slot_type=[typeName,Identifier]}
            |   |       |   |       |       |   |                   |   |___Token:. {id=1081,slot_type=DOT}
            |   |       |   |       |       |   |                   |   |___altnt_block__methodInvocation_13 {id=1082,slot_type=altnt_block__methodInvocation_13}
            |   |       |   |       |       |   |                   |       |___Token:get {id=1083,slot_type=Identifier}
            |   |       |   |       |       |   |                   |       |___Token:( {id=1084,slot_type=LPAREN}
            |   |       |   |       |       |   |                   |       |___(?) {id=1085,slot_type=optional__explicitConstructorInvocation_2}
            |   |       |   |       |       |   |                   |           |___Token:flushInterval {id=1105,slot_type=[argumentList,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,typeName,Identifier]}
            |   |       |   |       |       |   |                   |___Token:) {id=1078,slot_type=RPAREN}
            |   |       |   |       |       |   |___Token:; {id=1048,slot_type=SEMI}
            |   |       |   |       |       |___ifThenStatement {id=651,slot_type=[blockStatement,statement,ifThenStatement]}
            |   |       |   |       |       |   |___Token:if {id=652,slot_type=IF}
            |   |       |   |       |       |   |___Token:( {id=653,slot_type=LPAREN}
            |   |       |   |       |       |   |___equalityExpression {id=1017,slot_type=[expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression]}
            |   |       |   |       |       |   |   |___Token:pending {id=1045,slot_type=[relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,typeName,Identifier]}
            |   |       |   |       |       |   |   |___(*) {id=1019,slot_type=kleene_star__equalityExpression_1}
            |   |       |   |       |       |   |       |___aux_rule__equalityExpression_2 {id=1020,slot_type=aux_rule__equalityExpression_2}
            |   |       |   |       |       |   |           |___Token:== {id=1035,slot_type=[altnt_block__equalityExpression_3,EQUAL]}
            |   |       |   |       |       |   |           |___Token:null {id=1034,slot_type=[relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,literal,NullLiteral]}
            |   |       |   |       |       |   |___Token:) {id=655,slot_type=RPAREN}
            |   |       |   |       |       |   |___block {id=658,slot_type=[statement,statementWithoutTrailingSubstatement,block]}
            |   |       |   |       |       |       |___Token:{ {id=659,slot_type=LBRACE}
            |   |       |   |       |       |       |___(?) {id=660,slot_type=optional__block_1}
            |   |       |   |       |       |       |   |___(+) {id=662,slot_type=blockStatements}
            |   |       |   |       |       |       |       |___expressionStatement {id=971,slot_type=[blockStatement,statement,statementWithoutTrailingSubstatement,expressionStatement]}
            |   |       |   |       |       |       |       |   |___assignment {id=974,slot_type=[statementExpression,assignment]}
            |   |       |   |       |       |       |       |   |   |___Token:pending {id=1010,slot_type=[leftHandSide,typeName,Identifier]}
            |   |       |   |       |       |       |       |   |   |___Token:= {id=1008,slot_type=[assignmentOperator,ASSIGN]}
            |   |       |   |       |       |       |       |   |   |___classInstanceCreationExpression_lfno_primary {id=996,slot_type=[expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,classInstanceCreationExpression_lfno_primary]}
            |   |       |   |       |       |       |       |   |       |___aux_rule__classInstanceCreationExpression_lfno_primary_15 {id=1005,slot_type=[altnt_block__classInstanceCreationExpression_lfno_primary_14,aux_rule__classInstanceCreationExpression_lfno_primary_15]}
            |   |       |   |       |       |       |       |   |       |   |___Token:new {id=1006,slot_type=NEW}
            |   |       |   |       |       |       |       |   |       |   |___Token:ArrayList {id=1007,slot_type=Identifier}
            |   |       |   |       |       |       |       |   |       |___(?) {id=998,slot_type=optional__classInstanceCreationExpression_6}
            |   |       |   |       |       |       |       |   |       |   |___aux_rule__typeArgumentsOrDiamond_1 {id=1002,slot_type=[typeArgumentsOrDiamond,aux_rule__typeArgumentsOrDiamond_1]}
            |   |       |   |       |       |       |       |   |       |       |___Token:< {id=1003,slot_type=LT}
            |   |       |   |       |       |       |       |   |       |       |___Token:> {id=1004,slot_type=GT}
            |   |       |   |       |       |       |       |   |       |___Token:( {id=999,slot_type=LPAREN}
            |   |       |   |       |       |       |       |   |       |___Token:) {id=1000,slot_type=RPAREN}
            |   |       |   |       |       |       |       |   |___Token:; {id=973,slot_type=SEMI}
            |   |       |   |       |       |       |       |___localVariableDeclarationStatement {id=863,slot_type=[blockStatement,localVariableDeclarationStatement]}
            |   |       |   |       |       |       |       |   |___localVariableDeclaration {id=864,slot_type=localVariableDeclaration}
            |   |       |   |       |       |       |       |   |   |___Token:TimerTask {id=968,slot_type=[unannType,unannClassOrInterfaceType,altnt_block__unannClassOrInterfaceType_3,unannClassType_lfno_unannClassOrInterfaceType,Identifier]}
            |   |       |   |       |       |       |       |   |   |___variableDeclarator {id=868,slot_type=[variableDeclaratorList,variableDeclarator]}
            |   |       |   |       |       |       |       |   |       |___Token:t {id=964,slot_type=[variableDeclaratorId,Identifier]}
            |   |       |   |       |       |       |       |   |       |___(?) {id=870,slot_type=optional__variableDeclarator_2}
            |   |       |   |       |       |       |       |   |           |___aux_rule__variableDeclarator_1 {id=871,slot_type=aux_rule__variableDeclarator_1}
            |   |       |   |       |       |       |       |   |               |___Token:= {id=872,slot_type=ASSIGN}
            |   |       |   |       |       |       |       |   |               |___classInstanceCreationExpression_lfno_primary {id=893,slot_type=[variableInitializer,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,classInstanceCreationExpression_lfno_primary]}
            |   |       |   |       |       |       |       |   |                   |___aux_rule__classInstanceCreationExpression_lfno_primary_15 {id=961,slot_type=[altnt_block__classInstanceCreationExpression_lfno_primary_14,aux_rule__classInstanceCreationExpression_lfno_primary_15]}
            |   |       |   |       |       |       |       |   |                   |   |___Token:new {id=962,slot_type=NEW}
            |   |       |   |       |       |       |       |   |                   |   |___Token:TimerTask {id=963,slot_type=Identifier}
            |   |       |   |       |       |       |       |   |                   |___Token:( {id=895,slot_type=LPAREN}
            |   |       |   |       |       |       |       |   |                   |___Token:) {id=896,slot_type=RPAREN}
            |   |       |   |       |       |       |       |   |                   |___(?) {id=897,slot_type=optional__enumConstant_5}
            |   |       |   |       |       |       |       |   |                       |___classBody {id=898,slot_type=classBody}
            |   |       |   |       |       |       |       |   |                           |___Token:{ {id=899,slot_type=LBRACE}
            |   |       |   |       |       |       |       |   |                           |___(*) {id=900,slot_type=kleene_star__classBody_1}
            |   |       |   |       |       |       |       |   |                           |   |___methodDeclaration {id=903,slot_type=[classBodyDeclaration,methodDeclaration]}
            |   |       |   |       |       |       |       |   |                           |       |___(*) {id=904,slot_type=kleene_star__methodDeclaration_1}
            |   |       |   |       |       |       |       |   |                           |       |   |___markerAnnotation {id=957,slot_type=[methodModifier,annotation,markerAnnotation]}
            |   |       |   |       |       |       |       |   |                           |       |   |   |___Token:@ {id=958,slot_type=AT}
            |   |       |   |       |       |       |       |   |                           |       |   |   |___Token:Override {id=960,slot_type=[typeName,Identifier]}
            |   |       |   |       |       |       |       |   |                           |       |   |___Token:public {id=955,slot_type=[methodModifier,PUBLIC]}
            |   |       |   |       |       |       |       |   |                           |       |___methodHeader {id=905,slot_type=methodHeader}
            |   |       |   |       |       |       |       |   |                           |       |   |___Token:void {id=952,slot_type=[result,VOID]}
            |   |       |   |       |       |       |       |   |                           |       |   |___methodDeclarator {id=948,slot_type=methodDeclarator}
            |   |       |   |       |       |       |       |   |                           |       |       |___Token:run {id=949,slot_type=Identifier}
            |   |       |   |       |       |       |       |   |                           |       |       |___Token:( {id=950,slot_type=LPAREN}
            |   |       |   |       |       |       |       |   |                           |       |       |___Token:) {id=951,slot_type=RPAREN}
            |   |       |   |       |       |       |       |   |                           |       |___block {id=907,slot_type=[methodBody,block]}
            |   |       |   |       |       |       |       |   |                           |           |___Token:{ {id=908,slot_type=LBRACE}
            |   |       |   |       |       |       |       |   |                           |           |___(?) {id=909,slot_type=optional__block_1}
            |   |       |   |       |       |       |       |   |                           |           |   |___(+) {id=911,slot_type=blockStatements}
            |   |       |   |       |       |       |       |   |                           |           |       |___expressionStatement {id=915,slot_type=[blockStatement,statement,statementWithoutTrailingSubstatement,expressionStatement]}
            |   |       |   |       |       |       |       |   |                           |           |           |___methodInvocation {id=918,slot_type=[statementExpression,methodInvocation]}
            |   |       |   |       |       |       |       |   |                           |           |           |   |___aux_rule__methodInvocation_19 {id=921,slot_type=[altnt_block__methodInvocation_12,aux_rule__methodInvocation_19]}
            |   |       |   |       |       |       |       |   |                           |           |           |   |   |___Token:invokeAll {id=946,slot_type=[altnt_block__methodInvocation_16,methodName,Identifier]}
            |   |       |   |       |       |       |       |   |                           |           |           |   |   |___Token:( {id=923,slot_type=LPAREN}
            |   |       |   |       |       |       |       |   |                           |           |           |   |   |___(?) {id=924,slot_type=optional__explicitConstructorInvocation_2}
            |   |       |   |       |       |       |       |   |                           |           |           |   |       |___Token:flushInterval {id=944,slot_type=[argumentList,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,typeName,Identifier]}
            |   |       |   |       |       |       |       |   |                           |           |           |   |___Token:) {id=920,slot_type=RPAREN}
            |   |       |   |       |       |       |       |   |                           |           |           |___Token:; {id=917,slot_type=SEMI}
            |   |       |   |       |       |       |       |   |                           |           |___Token:} {id=910,slot_type=RBRACE}
            |   |       |   |       |       |       |       |   |                           |___Token:} {id=901,slot_type=RBRACE}
            |   |       |   |       |       |       |       |   |___Token:; {id=865,slot_type=SEMI}
            |   |       |   |       |       |       |       |___expressionStatement {id=807,slot_type=[blockStatement,statement,statementWithoutTrailingSubstatement,expressionStatement]}
            |   |       |   |       |       |       |       |   |___methodInvocation {id=810,slot_type=[statementExpression,methodInvocation]}
            |   |       |   |       |       |       |       |   |   |___aux_rule__methodInvocation_18 {id=813,slot_type=[altnt_block__methodInvocation_12,aux_rule__methodInvocation_18]}
            |   |       |   |       |       |       |       |   |   |   |___Token:_pendingFlush {id=862,slot_type=[typeName,Identifier]}
            |   |       |   |       |       |       |       |   |   |   |___Token:. {id=815,slot_type=DOT}
            |   |       |   |       |       |       |       |   |   |   |___altnt_block__methodInvocation_13 {id=816,slot_type=altnt_block__methodInvocation_13}
            |   |       |   |       |       |       |       |   |   |       |___Token:put {id=817,slot_type=Identifier}
            |   |       |   |       |       |       |       |   |   |       |___Token:( {id=818,slot_type=LPAREN}
            |   |       |   |       |       |       |       |   |   |       |___(?) {id=819,slot_type=optional__explicitConstructorInvocation_2}
            |   |       |   |       |       |       |       |   |   |           |___argumentList {id=820,slot_type=argumentList}
            |   |       |   |       |       |       |       |   |   |               |___Token:flushInterval {id=861,slot_type=[expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,typeName,Identifier]}
            |   |       |   |       |       |       |       |   |   |               |___(*) {id=822,slot_type=kleene_star__argumentList_2}
            |   |       |   |       |       |       |       |   |   |                   |___aux_rule__argumentList_1 {id=823,slot_type=aux_rule__argumentList_1}
            |   |       |   |       |       |       |       |   |   |                       |___Token:, {id=824,slot_type=COMMA}
            |   |       |   |       |       |       |       |   |   |                       |___Token:pending {id=843,slot_type=[expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,typeName,Identifier]}
            |   |       |   |       |       |       |       |   |   |___Token:) {id=812,slot_type=RPAREN}
            |   |       |   |       |       |       |       |   |___Token:; {id=809,slot_type=SEMI}
            |   |       |   |       |       |       |       |___expressionStatement {id=728,slot_type=[blockStatement,statement,statementWithoutTrailingSubstatement,expressionStatement]}
            |   |       |   |       |       |       |       |   |___methodInvocation {id=731,slot_type=[statementExpression,methodInvocation]}
            |   |       |   |       |       |       |       |   |   |___aux_rule__methodInvocation_18 {id=734,slot_type=[altnt_block__methodInvocation_12,aux_rule__methodInvocation_18]}
            |   |       |   |       |       |       |       |   |   |   |___Token:_timer {id=804,slot_type=[typeName,Identifier]}
            |   |       |   |       |       |       |       |   |   |   |___Token:. {id=736,slot_type=DOT}
            |   |       |   |       |       |       |       |   |   |   |___altnt_block__methodInvocation_13 {id=737,slot_type=altnt_block__methodInvocation_13}
            |   |       |   |       |       |       |       |   |   |       |___Token:schedule {id=738,slot_type=Identifier}
            |   |       |   |       |       |       |       |   |   |       |___Token:( {id=739,slot_type=LPAREN}
            |   |       |   |       |       |       |       |   |   |       |___(?) {id=740,slot_type=optional__explicitConstructorInvocation_2}
            |   |       |   |       |       |       |       |   |   |           |___argumentList {id=741,slot_type=argumentList}
            |   |       |   |       |       |       |       |   |   |               |___Token:t {id=803,slot_type=[expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,typeName,Identifier]}
            |   |       |   |       |       |       |       |   |   |               |___(*) {id=743,slot_type=kleene_star__argumentList_2}
            |   |       |   |       |       |       |       |   |   |                   |___aux_rule__argumentList_1 {id=744,slot_type=aux_rule__argumentList_1}
            |   |       |   |       |       |       |       |   |   |                   |   |___Token:, {id=766,slot_type=COMMA}
            |   |       |   |       |       |       |       |   |   |                   |   |___Token:flushInterval {id=785,slot_type=[expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,typeName,Identifier]}
            |   |       |   |       |       |       |       |   |   |                   |___aux_rule__argumentList_1 {id=745,slot_type=aux_rule__argumentList_1}
            |   |       |   |       |       |       |       |   |   |                       |___Token:, {id=746,slot_type=COMMA}
            |   |       |   |       |       |       |       |   |   |                       |___Token:flushInterval {id=765,slot_type=[expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,typeName,Identifier]}
            |   |       |   |       |       |       |       |   |   |___Token:) {id=733,slot_type=RPAREN}
            |   |       |   |       |       |       |       |   |___Token:; {id=730,slot_type=SEMI}
            |   |       |   |       |       |       |       |___expressionStatement {id=670,slot_type=[blockStatement,statement,statementWithoutTrailingSubstatement,expressionStatement]}
            |   |       |   |       |       |       |           |___methodInvocation {id=673,slot_type=[statementExpression,methodInvocation]}
            |   |       |   |       |       |       |           |   |___aux_rule__methodInvocation_18 {id=676,slot_type=[altnt_block__methodInvocation_12,aux_rule__methodInvocation_18]}
            |   |       |   |       |       |       |           |   |   |___Token:_tt {id=725,slot_type=[typeName,Identifier]}
            |   |       |   |       |       |       |           |   |   |___Token:. {id=678,slot_type=DOT}
            |   |       |   |       |       |       |           |   |   |___altnt_block__methodInvocation_13 {id=679,slot_type=altnt_block__methodInvocation_13}
            |   |       |   |       |       |       |           |   |       |___Token:put {id=680,slot_type=Identifier}
            |   |       |   |       |       |       |           |   |       |___Token:( {id=681,slot_type=LPAREN}
            |   |       |   |       |       |       |           |   |       |___(?) {id=682,slot_type=optional__explicitConstructorInvocation_2}
            |   |       |   |       |       |       |           |   |           |___argumentList {id=683,slot_type=argumentList}
            |   |       |   |       |       |       |           |   |               |___Token:flushInterval {id=724,slot_type=[expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,typeName,Identifier]}
            |   |       |   |       |       |       |           |   |               |___(*) {id=685,slot_type=kleene_star__argumentList_2}
            |   |       |   |       |       |       |           |   |                   |___aux_rule__argumentList_1 {id=686,slot_type=aux_rule__argumentList_1}
            |   |       |   |       |       |       |           |   |                       |___Token:, {id=687,slot_type=COMMA}
            |   |       |   |       |       |       |           |   |                       |___Token:t {id=706,slot_type=[expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,typeName,Identifier]}
            |   |       |   |       |       |       |           |   |___Token:) {id=675,slot_type=RPAREN}
            |   |       |   |       |       |       |           |___Token:; {id=672,slot_type=SEMI}
            |   |       |   |       |       |       |___Token:} {id=661,slot_type=RBRACE}
            |   |       |   |       |       |___expressionStatement {id=616,slot_type=[blockStatement,statement,statementWithoutTrailingSubstatement,expressionStatement]}
            |   |       |   |       |           |___methodInvocation {id=619,slot_type=[statementExpression,methodInvocation]}
            |   |       |   |       |           |   |___aux_rule__methodInvocation_18 {id=622,slot_type=[altnt_block__methodInvocation_12,aux_rule__methodInvocation_18]}
            |   |       |   |       |           |   |   |___Token:pending {id=649,slot_type=[typeName,Identifier]}
            |   |       |   |       |           |   |   |___Token:. {id=624,slot_type=DOT}
            |   |       |   |       |           |   |   |___altnt_block__methodInvocation_13 {id=625,slot_type=altnt_block__methodInvocation_13}
            |   |       |   |       |           |   |       |___Token:add {id=626,slot_type=Identifier}
            |   |       |   |       |           |   |       |___Token:( {id=627,slot_type=LPAREN}
            |   |       |   |       |           |   |       |___(?) {id=628,slot_type=optional__explicitConstructorInvocation_2}
            |   |       |   |       |           |   |           |___Token:flusher {id=648,slot_type=[argumentList,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,typeName,Identifier]}
            |   |       |   |       |           |   |___Token:) {id=621,slot_type=RPAREN}
            |   |       |   |       |           |___Token:; {id=618,slot_type=SEMI}
            |   |       |   |       |___Token:} {id=609,slot_type=RBRACE}
            |   |       |   |___methodDeclaration {id=369,slot_type=[classBodyDeclaration,methodDeclaration]}
            |   |       |   |   |___(*) {id=370,slot_type=kleene_star__methodDeclaration_1}
            |   |       |   |   |   |___Token:private {id=601,slot_type=[methodModifier,PRIVATE]}
            |   |       |   |   |   |___Token:synchronized {id=600,slot_type=[methodModifier,SYNCHRONIZED]}
            |   |       |   |   |___methodHeader {id=371,slot_type=methodHeader}
            |   |       |   |   |   |___Token:void {id=597,slot_type=[result,VOID]}
            |   |       |   |   |   |___methodDeclarator {id=583,slot_type=methodDeclarator}
            |   |       |   |   |       |___Token:invokeAll {id=584,slot_type=Identifier}
            |   |       |   |   |       |___Token:( {id=585,slot_type=LPAREN}
            |   |       |   |   |       |___(?) {id=586,slot_type=optional__methodDeclarator_1}
            |   |       |   |   |       |   |___formalParameter {id=591,slot_type=[formalParameterList,aux_rule__formalParameterList_3,lastFormalParameter,formalParameter]}
            |   |       |   |   |       |       |___Token:int {id=596,slot_type=[unannType,altnt_block__primitiveType_3,INT]}
            |   |       |   |   |       |       |___Token:flushInterval {id=594,slot_type=[variableDeclaratorId,Identifier]}
            |   |       |   |   |       |___Token:) {id=587,slot_type=RPAREN}
            |   |       |   |   |___block {id=373,slot_type=[methodBody,block]}
            |   |       |   |       |___Token:{ {id=374,slot_type=LBRACE}
            |   |       |   |       |___(?) {id=375,slot_type=optional__block_1}
            |   |       |   |       |   |___(+) {id=377,slot_type=blockStatements}
            |   |       |   |       |       |___localVariableDeclarationStatement {id=505,slot_type=[blockStatement,localVariableDeclarationStatement]}
            |   |       |   |       |       |   |___localVariableDeclaration {id=506,slot_type=localVariableDeclaration}
            |   |       |   |       |       |   |   |___unannClassType_lfno_unannClassOrInterfaceType {id=569,slot_type=[unannType,unannClassOrInterfaceType,altnt_block__unannClassOrInterfaceType_3,unannClassType_lfno_unannClassOrInterfaceType]}
            |   |       |   |       |       |   |   |   |___Token:ArrayList {id=570,slot_type=Identifier}
            |   |       |   |       |       |   |   |   |___(?) {id=571,slot_type=optional__classType_lfno_classOrInterfaceType_2}
            |   |       |   |       |       |   |   |       |___typeArguments {id=572,slot_type=typeArguments}
            |   |       |   |       |       |   |   |           |___Token:< {id=573,slot_type=LT}
            |   |       |   |       |       |   |   |           |___Token:Flusher {id=581,slot_type=[typeArgumentList,typeArgument,referenceType,classOrInterfaceType,altnt_block__classOrInterfaceType_3,classType_lfno_classOrInterfaceType,Identifier]}
            |   |       |   |       |       |   |   |           |___Token:> {id=575,slot_type=GT}
            |   |       |   |       |       |   |   |___variableDeclarator {id=510,slot_type=[variableDeclaratorList,variableDeclarator]}
            |   |       |   |       |       |   |       |___Token:tasks {id=566,slot_type=[variableDeclaratorId,Identifier]}
            |   |       |   |       |       |   |       |___(?) {id=512,slot_type=optional__variableDeclarator_2}
            |   |       |   |       |       |   |           |___aux_rule__variableDeclarator_1 {id=513,slot_type=aux_rule__variableDeclarator_1}
            |   |       |   |       |       |   |               |___Token:= {id=514,slot_type=ASSIGN}
            |   |       |   |       |       |   |               |___methodInvocation_lfno_primary {id=535,slot_type=[variableInitializer,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,methodInvocation_lfno_primary]}
            |   |       |   |       |       |   |                   |___aux_rule__methodInvocation_lfno_primary_14 {id=538,slot_type=[altnt_block__methodInvocation_lfno_primary_10,aux_rule__methodInvocation_lfno_primary_14]}
            |   |       |   |       |       |   |                   |   |___Token:_pendingFlush {id=565,slot_type=[typeName,Identifier]}
            |   |       |   |       |       |   |                   |   |___Token:. {id=540,slot_type=DOT}
            |   |       |   |       |       |   |                   |   |___altnt_block__methodInvocation_13 {id=541,slot_type=altnt_block__methodInvocation_13}
            |   |       |   |       |       |   |                   |       |___Token:get {id=542,slot_type=Identifier}
            |   |       |   |       |       |   |                   |       |___Token:( {id=543,slot_type=LPAREN}
            |   |       |   |       |       |   |                   |       |___(?) {id=544,slot_type=optional__explicitConstructorInvocation_2}
            |   |       |   |       |       |   |                   |           |___Token:flushInterval {id=564,slot_type=[argumentList,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,typeName,Identifier]}
            |   |       |   |       |       |   |                   |___Token:) {id=537,slot_type=RPAREN}
            |   |       |   |       |       |   |___Token:; {id=507,slot_type=SEMI}
            |   |       |   |       |       |___ifThenStatement {id=381,slot_type=[blockStatement,statement,ifThenStatement]}
            |   |       |   |       |           |___Token:if {id=382,slot_type=IF}
            |   |       |   |       |           |___Token:( {id=383,slot_type=LPAREN}
            |   |       |   |       |           |___equalityExpression {id=476,slot_type=[expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression]}
            |   |       |   |       |           |   |___Token:tasks {id=504,slot_type=[relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,typeName,Identifier]}
            |   |       |   |       |           |   |___(*) {id=478,slot_type=kleene_star__equalityExpression_1}
            |   |       |   |       |           |       |___aux_rule__equalityExpression_2 {id=479,slot_type=aux_rule__equalityExpression_2}
            |   |       |   |       |           |           |___Token:!= {id=494,slot_type=[altnt_block__equalityExpression_3,NOTEQUAL]}
            |   |       |   |       |           |           |___Token:null {id=493,slot_type=[relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,literal,NullLiteral]}
            |   |       |   |       |           |___Token:) {id=385,slot_type=RPAREN}
            |   |       |   |       |           |___block {id=388,slot_type=[statement,statementWithoutTrailingSubstatement,block]}
            |   |       |   |       |               |___Token:{ {id=389,slot_type=LBRACE}
            |   |       |   |       |               |___(?) {id=390,slot_type=optional__block_1}
            |   |       |   |       |               |   |___(+) {id=392,slot_type=blockStatements}
            |   |       |   |       |               |       |___enhancedForStatement {id=395,slot_type=[blockStatement,statement,enhancedForStatement]}
            |   |       |   |       |               |           |___Token:for {id=396,slot_type=FOR}
            |   |       |   |       |               |           |___Token:( {id=397,slot_type=LPAREN}
            |   |       |   |       |               |           |___Token:Flusher {id=469,slot_type=[unannType,unannClassOrInterfaceType,altnt_block__unannClassOrInterfaceType_3,unannClassType_lfno_unannClassOrInterfaceType,Identifier]}
            |   |       |   |       |               |           |___Token:f {id=465,slot_type=[variableDeclaratorId,Identifier]}
            |   |       |   |       |               |           |___Token:: {id=400,slot_type=COLON}
            |   |       |   |       |               |           |___Token:tasks {id=464,slot_type=[expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,typeName,Identifier]}
            |   |       |   |       |               |           |___Token:) {id=402,slot_type=RPAREN}
            |   |       |   |       |               |           |___block {id=405,slot_type=[statement,statementWithoutTrailingSubstatement,block]}
            |   |       |   |       |               |               |___Token:{ {id=406,slot_type=LBRACE}
            |   |       |   |       |               |               |___(?) {id=407,slot_type=optional__block_1}
            |   |       |   |       |               |               |   |___(+) {id=409,slot_type=blockStatements}
            |   |       |   |       |               |               |       |___expressionStatement {id=413,slot_type=[blockStatement,statement,statementWithoutTrailingSubstatement,expressionStatement]}
            |   |       |   |       |               |               |           |___methodInvocation {id=416,slot_type=[statementExpression,methodInvocation]}
            |   |       |   |       |               |               |           |   |___aux_rule__methodInvocation_18 {id=419,slot_type=[altnt_block__methodInvocation_12,aux_rule__methodInvocation_18]}
            |   |       |   |       |               |               |           |   |   |___Token:_exec {id=446,slot_type=[typeName,Identifier]}
            |   |       |   |       |               |               |           |   |   |___Token:. {id=421,slot_type=DOT}
            |   |       |   |       |               |               |           |   |   |___altnt_block__methodInvocation_13 {id=422,slot_type=altnt_block__methodInvocation_13}
            |   |       |   |       |               |               |           |   |       |___Token:submit {id=423,slot_type=Identifier}
            |   |       |   |       |               |               |           |   |       |___Token:( {id=424,slot_type=LPAREN}
            |   |       |   |       |               |               |           |   |       |___(?) {id=425,slot_type=optional__explicitConstructorInvocation_2}
            |   |       |   |       |               |               |           |   |           |___Token:f {id=445,slot_type=[argumentList,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,typeName,Identifier]}
            |   |       |   |       |               |               |           |   |___Token:) {id=418,slot_type=RPAREN}
            |   |       |   |       |               |               |           |___Token:; {id=415,slot_type=SEMI}
            |   |       |   |       |               |               |___Token:} {id=408,slot_type=RBRACE}
            |   |       |   |       |               |___Token:} {id=391,slot_type=RBRACE}
            |   |       |   |       |___Token:} {id=376,slot_type=RBRACE}
            |   |       |   |___methodDeclaration {id=67,slot_type=[classBodyDeclaration,methodDeclaration]}
            |   |       |       |___(*) {id=68,slot_type=kleene_star__methodDeclaration_1}
            |   |       |       |   |___Token:public {id=368,slot_type=[methodModifier,PUBLIC]}
            |   |       |       |   |___Token:synchronized {id=367,slot_type=[methodModifier,SYNCHRONIZED]}
            |   |       |       |___methodHeader {id=69,slot_type=methodHeader}
            |   |       |       |   |___Token:void {id=364,slot_type=[result,VOID]}
            |   |       |       |   |___methodDeclarator {id=337,slot_type=methodDeclarator}
            |   |       |       |       |___Token:stop {id=338,slot_type=Identifier}
            |   |       |       |       |___Token:( {id=339,slot_type=LPAREN}
            |   |       |       |       |___(?) {id=340,slot_type=optional__methodDeclarator_1}
            |   |       |       |       |   |___aux_rule__formalParameterList_3 {id=343,slot_type=[formalParameterList,aux_rule__formalParameterList_3]}
            |   |       |       |       |       |___(?) {id=344,slot_type=optional__formalParameterList_2}
            |   |       |       |       |       |   |___aux_rule__formalParameterList_1 {id=352,slot_type=aux_rule__formalParameterList_1}
            |   |       |       |       |       |       |___formalParameter {id=356,slot_type=[formalParameters,altnt_block__formalParameters_5,formalParameter]}
            |   |       |       |       |       |       |   |___Token:Flusher {id=363,slot_type=[unannType,unannClassOrInterfaceType,altnt_block__unannClassOrInterfaceType_3,unannClassType_lfno_unannClassOrInterfaceType,Identifier]}
            |   |       |       |       |       |       |   |___Token:flusher {id=359,slot_type=[variableDeclaratorId,Identifier]}
            |   |       |       |       |       |       |___Token:, {id=354,slot_type=COMMA}
            |   |       |       |       |       |___formalParameter {id=346,slot_type=[lastFormalParameter,formalParameter]}
            |   |       |       |       |           |___Token:long {id=351,slot_type=[unannType,altnt_block__primitiveType_3,LONG]}
            |   |       |       |       |           |___Token:flushInterval {id=349,slot_type=[variableDeclaratorId,Identifier]}
            |   |       |       |       |___Token:) {id=341,slot_type=RPAREN}
            |   |       |       |___block {id=71,slot_type=[methodBody,block]}
            |   |       |           |___Token:{ {id=72,slot_type=LBRACE}
            |   |       |           |___(?) {id=73,slot_type=optional__block_1}
            |   |       |           |   |___(+) {id=75,slot_type=blockStatements}
            |   |       |           |       |___localVariableDeclarationStatement {id=259,slot_type=[blockStatement,localVariableDeclarationStatement]}
            |   |       |           |       |   |___localVariableDeclaration {id=260,slot_type=localVariableDeclaration}
            |   |       |           |       |   |   |___unannClassType_lfno_unannClassOrInterfaceType {id=323,slot_type=[unannType,unannClassOrInterfaceType,altnt_block__unannClassOrInterfaceType_3,unannClassType_lfno_unannClassOrInterfaceType]}
            |   |       |           |       |   |   |   |___Token:ArrayList {id=324,slot_type=Identifier}
            |   |       |           |       |   |   |   |___(?) {id=325,slot_type=optional__classType_lfno_classOrInterfaceType_2}
            |   |       |           |       |   |   |       |___typeArguments {id=326,slot_type=typeArguments}
            |   |       |           |       |   |   |           |___Token:< {id=327,slot_type=LT}
            |   |       |           |       |   |   |           |___Token:Flusher {id=335,slot_type=[typeArgumentList,typeArgument,referenceType,classOrInterfaceType,altnt_block__classOrInterfaceType_3,classType_lfno_classOrInterfaceType,Identifier]}
            |   |       |           |       |   |   |           |___Token:> {id=329,slot_type=GT}
            |   |       |           |       |   |   |___variableDeclarator {id=264,slot_type=[variableDeclaratorList,variableDeclarator]}
            |   |       |           |       |   |       |___Token:pending {id=320,slot_type=[variableDeclaratorId,Identifier]}
            |   |       |           |       |   |       |___(?) {id=266,slot_type=optional__variableDeclarator_2}
            |   |       |           |       |   |           |___aux_rule__variableDeclarator_1 {id=267,slot_type=aux_rule__variableDeclarator_1}
            |   |       |           |       |   |               |___Token:= {id=268,slot_type=ASSIGN}
            |   |       |           |       |   |               |___methodInvocation_lfno_primary {id=289,slot_type=[variableInitializer,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,methodInvocation_lfno_primary]}
            |   |       |           |       |   |                   |___aux_rule__methodInvocation_lfno_primary_14 {id=292,slot_type=[altnt_block__methodInvocation_lfno_primary_10,aux_rule__methodInvocation_lfno_primary_14]}
            |   |       |           |       |   |                   |   |___Token:_pendingFlush {id=319,slot_type=[typeName,Identifier]}
            |   |       |           |       |   |                   |   |___Token:. {id=294,slot_type=DOT}
            |   |       |           |       |   |                   |   |___altnt_block__methodInvocation_13 {id=295,slot_type=altnt_block__methodInvocation_13}
            |   |       |           |       |   |                   |       |___Token:get {id=296,slot_type=Identifier}
            |   |       |           |       |   |                   |       |___Token:( {id=297,slot_type=LPAREN}
            |   |       |           |       |   |                   |       |___(?) {id=298,slot_type=optional__explicitConstructorInvocation_2}
            |   |       |           |       |   |                   |           |___Token:flushInterval {id=318,slot_type=[argumentList,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,typeName,Identifier]}
            |   |       |           |       |   |                   |___Token:) {id=291,slot_type=RPAREN}
            |   |       |           |       |   |___Token:; {id=261,slot_type=SEMI}
            |   |       |           |       |___expressionStatement {id=225,slot_type=[blockStatement,statement,statementWithoutTrailingSubstatement,expressionStatement]}
            |   |       |           |       |   |___methodInvocation {id=228,slot_type=[statementExpression,methodInvocation]}
            |   |       |           |       |   |   |___aux_rule__methodInvocation_18 {id=231,slot_type=[altnt_block__methodInvocation_12,aux_rule__methodInvocation_18]}
            |   |       |           |       |   |   |   |___Token:pending {id=258,slot_type=[typeName,Identifier]}
            |   |       |           |       |   |   |   |___Token:. {id=233,slot_type=DOT}
            |   |       |           |       |   |   |   |___altnt_block__methodInvocation_13 {id=234,slot_type=altnt_block__methodInvocation_13}
            |   |       |           |       |   |   |       |___Token:remove {id=235,slot_type=Identifier}
            |   |       |           |       |   |   |       |___Token:( {id=236,slot_type=LPAREN}
            |   |       |           |       |   |   |       |___(?) {id=237,slot_type=optional__explicitConstructorInvocation_2}
            |   |       |           |       |   |   |           |___Token:flusher {id=257,slot_type=[argumentList,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,typeName,Identifier]}
            |   |       |           |       |   |   |___Token:) {id=230,slot_type=RPAREN}
            |   |       |           |       |   |___Token:; {id=227,slot_type=SEMI}
            |   |       |           |       |___ifThenStatement {id=80,slot_type=[blockStatement,statement,ifThenStatement]}
            |   |       |           |           |___Token:if {id=81,slot_type=IF}
            |   |       |           |           |___Token:( {id=82,slot_type=LPAREN}
            |   |       |           |           |___equalityExpression {id=184,slot_type=[expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression]}
            |   |       |           |           |   |___methodInvocation_lfno_primary {id=213,slot_type=[relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,methodInvocation_lfno_primary]}
            |   |       |           |           |   |   |___aux_rule__methodInvocation_lfno_primary_14 {id=216,slot_type=[altnt_block__methodInvocation_lfno_primary_10,aux_rule__methodInvocation_lfno_primary_14]}
            |   |       |           |           |   |   |   |___Token:pending {id=222,slot_type=[typeName,Identifier]}
            |   |       |           |           |   |   |   |___Token:. {id=218,slot_type=DOT}
            |   |       |           |           |   |   |   |___altnt_block__methodInvocation_13 {id=219,slot_type=altnt_block__methodInvocation_13}
            |   |       |           |           |   |   |       |___Token:size {id=220,slot_type=Identifier}
            |   |       |           |           |   |   |       |___Token:( {id=221,slot_type=LPAREN}
            |   |       |           |           |   |   |___Token:) {id=215,slot_type=RPAREN}
            |   |       |           |           |   |___(*) {id=186,slot_type=kleene_star__equalityExpression_1}
            |   |       |           |           |       |___aux_rule__equalityExpression_2 {id=187,slot_type=aux_rule__equalityExpression_2}
            |   |       |           |           |           |___Token:== {id=202,slot_type=[altnt_block__equalityExpression_3,EQUAL]}
            |   |       |           |           |           |___Token:0 {id=201,slot_type=[relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,literal,IntegerLiteral]}
            |   |       |           |           |___Token:) {id=84,slot_type=RPAREN}
            |   |       |           |           |___block {id=87,slot_type=[statement,statementWithoutTrailingSubstatement,block]}
            |   |       |           |               |___Token:{ {id=88,slot_type=LBRACE}
            |   |       |           |               |___(?) {id=89,slot_type=optional__block_1}
            |   |       |           |               |   |___(+) {id=91,slot_type=blockStatements}
            |   |       |           |               |       |___expressionStatement {id=144,slot_type=[blockStatement,statement,statementWithoutTrailingSubstatement,expressionStatement]}
            |   |       |           |               |       |   |___methodInvocation {id=147,slot_type=[statementExpression,methodInvocation]}
            |   |       |           |               |       |   |   |___aux_rule__methodInvocation_18 {id=150,slot_type=[altnt_block__methodInvocation_12,aux_rule__methodInvocation_18]}
            |   |       |           |               |       |   |   |   |___Token:_pendingFlush {id=177,slot_type=[typeName,Identifier]}
            |   |       |           |               |       |   |   |   |___Token:. {id=152,slot_type=DOT}
            |   |       |           |               |       |   |   |   |___altnt_block__methodInvocation_13 {id=153,slot_type=altnt_block__methodInvocation_13}
            |   |       |           |               |       |   |   |       |___Token:remove {id=154,slot_type=Identifier}
            |   |       |           |               |       |   |   |       |___Token:( {id=155,slot_type=LPAREN}
            |   |       |           |               |       |   |   |       |___(?) {id=156,slot_type=optional__explicitConstructorInvocation_2}
            |   |       |           |               |       |   |   |           |___Token:flushInterval {id=176,slot_type=[argumentList,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,typeName,Identifier]}
            |   |       |           |               |       |   |   |___Token:) {id=149,slot_type=RPAREN}
            |   |       |           |               |       |   |___Token:; {id=146,slot_type=SEMI}
            |   |       |           |               |       |___expressionStatement {id=96,slot_type=[blockStatement,statement,statementWithoutTrailingSubstatement,expressionStatement]}
            |   |       |           |               |           |___methodInvocation {id=99,slot_type=[statementExpression,methodInvocation]}
            |   |       |           |               |           |   |___aux_rule__methodInvocation_19 {id=102,slot_type=[altnt_block__methodInvocation_12,aux_rule__methodInvocation_19]}
            |   |       |           |               |           |   |   |___aux_rule__methodInvocation_20 {id=105,slot_type=[altnt_block__methodInvocation_16,aux_rule__methodInvocation_20]}
            |   |       |           |               |           |   |   |   |___methodInvocation_lfno_primary {id=111,slot_type=[altnt_block__methodInvocation_17,primary,altnt_block__primary_2,methodInvocation_lfno_primary]}
            |   |       |           |               |           |   |   |   |   |___aux_rule__methodInvocation_lfno_primary_14 {id=114,slot_type=[altnt_block__methodInvocation_lfno_primary_10,aux_rule__methodInvocation_lfno_primary_14]}
            |   |       |           |               |           |   |   |   |   |   |___Token:_tt {id=141,slot_type=[typeName,Identifier]}
            |   |       |           |               |           |   |   |   |   |   |___Token:. {id=116,slot_type=DOT}
            |   |       |           |               |           |   |   |   |   |   |___altnt_block__methodInvocation_13 {id=117,slot_type=altnt_block__methodInvocation_13}
            |   |       |           |               |           |   |   |   |   |       |___Token:remove {id=118,slot_type=Identifier}
            |   |       |           |               |           |   |   |   |   |       |___Token:( {id=119,slot_type=LPAREN}
            |   |       |           |               |           |   |   |   |   |       |___(?) {id=120,slot_type=optional__explicitConstructorInvocation_2}
            |   |       |           |               |           |   |   |   |   |           |___Token:flushInterval {id=140,slot_type=[argumentList,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,typeName,Identifier]}
            |   |       |           |               |           |   |   |   |   |___Token:) {id=113,slot_type=RPAREN}
            |   |       |           |               |           |   |   |   |___Token:. {id=107,slot_type=DOT}
            |   |       |           |               |           |   |   |   |___Token:cancel {id=108,slot_type=Identifier}
            |   |       |           |               |           |   |   |___Token:( {id=104,slot_type=LPAREN}
            |   |       |           |               |           |   |___Token:) {id=101,slot_type=RPAREN}
            |   |       |           |               |           |___Token:; {id=98,slot_type=SEMI}
            |   |       |           |               |___Token:} {id=90,slot_type=RBRACE}
            |   |       |           |___Token:} {id=74,slot_type=RBRACE}
            |   |       |___Token:} {id=59,slot_type=RBRACE}
            |   |___normalClassDeclaration {id=18,slot_type=[classBodyDeclaration,classDeclaration,normalClassDeclaration]}
            |       |___(*) {id=19,slot_type=kleene_star__normalClassDeclaration_1}
            |       |   |___Token:private {id=50,slot_type=[classModifier,PRIVATE]}
            |       |___Token:class {id=20,slot_type=CLASS}
            |       |___Token:Flusher {id=21,slot_type=Identifier}
            |       |___(?) {id=22,slot_type=optional__normalClassDeclaration_4}
            |       |   |___superinterfaces {id=43,slot_type=superinterfaces}
            |       |       |___Token:implements {id=44,slot_type=IMPLEMENTS}
            |       |       |___Token:Runnable {id=48,slot_type=[interfaceTypeList,interfaceType,classType,Identifier]}
            |       |___classBody {id=23,slot_type=classBody}
            |           |___Token:{ {id=24,slot_type=LBRACE}
            |           |___(*) {id=25,slot_type=kleene_star__classBody_1}
            |           |   |___methodDeclaration {id=28,slot_type=[classBodyDeclaration,methodDeclaration]}
            |           |       |___(*) {id=29,slot_type=kleene_star__methodDeclaration_1}
            |           |       |   |___Token:public {id=42,slot_type=[methodModifier,PUBLIC]}
            |           |       |___methodHeader {id=30,slot_type=methodHeader}
            |           |       |   |___Token:void {id=40,slot_type=[result,VOID]}
            |           |       |   |___methodDeclarator {id=36,slot_type=methodDeclarator}
            |           |       |       |___Token:run {id=37,slot_type=Identifier}
            |           |       |       |___Token:( {id=38,slot_type=LPAREN}
            |           |       |       |___Token:) {id=39,slot_type=RPAREN}
            |           |       |___block {id=32,slot_type=[methodBody,block]}
            |           |           |___Token:{ {id=33,slot_type=LBRACE}
            |           |           |___Token:} {id=34,slot_type=RBRACE}
            |           |___Token:} {id=26,slot_type=RBRACE}
            |___Token:} {id=13,slot_type=RBRACE}
------------------------------------------------------------


=================Reducing node 3, size=462==================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
        private static final FlusherPool FLUSHER = new FlusherPool();
        private static class FlusherPool {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
            public synchronized void stop(Flusher flusher, long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                pending.remove(flusher);
                if (pending.size() == 0) {
                    _pendingFlush.remove(flushInterval);
                    _tt.remove(flushInterval).cancel();
                }
            }
        }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_3]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 3
------------------------------------------------------------


=================Reducing node 6, size=462==================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
        private static final FlusherPool FLUSHER = new FlusherPool();
        private static class FlusherPool {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
            public synchronized void stop(Flusher flusher, long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                pending.remove(flusher);
                if (pending.size() == 0) {
                    _pendingFlush.remove(flushInterval);
                    _tt.remove(flushInterval).cancel();
                }
            }
        }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=6}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
        private class Flusher implements Runnable {
            public void run() {
            }
        }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
        private static class FlusherPool {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
            public synchronized void stop(Flusher flusher, long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                pending.remove(flusher);
                if (pending.size() == 0) {
                    _pendingFlush.remove(flushInterval);
                    _tt.remove(flushInterval).cancel();
                }
            }
        }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
        private static class FlusherPool {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
            public synchronized void stop(Flusher flusher, long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                pending.remove(flusher);
                if (pending.size() == 0) {
                    _pendingFlush.remove(flushInterval);
                    _tt.remove(flushInterval).cancel();
                }
            }
        }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 6
------------------------------------------------------------


=================Reducing node 10, size=462=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
        private static final FlusherPool FLUSHER = new FlusherPool();
        private static class FlusherPool {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
            public synchronized void stop(Flusher flusher, long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                pending.remove(flusher);
                if (pending.size() == 0) {
                    _pendingFlush.remove(flushInterval);
                    _tt.remove(flushInterval).cancel();
                }
            }
        }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test
                                                  {
            public void run() {
            }
        }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test
                                                  {
            public void run() {
            }
        }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test
                                         {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
            public synchronized void stop(Flusher flusher, long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                pending.remove(flusher);
                if (pending.size() == 0) {
                    _pendingFlush.remove(flushInterval);
                    _tt.remove(flushInterval).cancel();
                }
            }
        }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test
                                         {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
            public synchronized void stop(Flusher flusher, long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                pending.remove(flusher);
                if (pending.size() == 0) {
                    _pendingFlush.remove(flushInterval);
                    _tt.remove(flushInterval).cancel();
                }
            }
        }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 10
------------------------------------------------------------


=================Reducing node 12, size=462=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
        private static final FlusherPool FLUSHER = new FlusherPool();
        private static class FlusherPool {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
            public synchronized void stop(Flusher flusher, long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                pending.remove(flusher);
                if (pending.size() == 0) {
                    _pendingFlush.remove(flushInterval);
                    _tt.remove(flushInterval).cancel();
                }
            }
        }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@3
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
        private static final FlusherPool FLUSHER = new FlusherPool();
        private static class FlusherPool {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
            public synchronized void stop(Flusher flusher, long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                pending.remove(flusher);
                if (pending.size() == 0) {
                    _pendingFlush.remove(flushInterval);
                    _tt.remove(flushInterval).cancel();
                }
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
        private static final FlusherPool FLUSHER = new FlusherPool();
        private static class FlusherPool {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
            public synchronized void stop(Flusher flusher, long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                pending.remove(flusher);
                if (pending.size() == 0) {
                    _pendingFlush.remove(flushInterval);
                    _tt.remove(flushInterval).cancel();
                }
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@2
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
        private static final FlusherPool FLUSHER = new FlusherPool();
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
        private static final FlusherPool FLUSHER = new FlusherPool();
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
        private static class FlusherPool {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
            public synchronized void stop(Flusher flusher, long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                pending.remove(flusher);
                if (pending.size() == 0) {
                    _pendingFlush.remove(flushInterval);
                    _tt.remove(flushInterval).cancel();
                }
            }
        }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
        private static class FlusherPool {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
            public synchronized void stop(Flusher flusher, long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                pending.remove(flusher);
                if (pending.size() == 0) {
                    _pendingFlush.remove(flushInterval);
                    _tt.remove(flushInterval).cancel();
                }
            }
        }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 10
------------------------------------------------------------


================The best program is updated.================

token count change 462 -> 451
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 12 from 462 to 451
------------------------------------------------------------


=================Reducing node 52, size=451=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
        private static class FlusherPool {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
            public synchronized void stop(Flusher flusher, long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                pending.remove(flusher);
                if (pending.size() == 0) {
                    _pendingFlush.remove(flushInterval);
                    _tt.remove(flushInterval).cancel();
                }
            }
        }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
                                                                   {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
                                                                   {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
                                                                               {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                pending.remove(flusher);
                if (pending.size() == 0) {
                    _pendingFlush.remove(flushInterval);
                    _tt.remove(flushInterval).cancel();
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
                                                                               {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                pending.remove(flusher);
                if (pending.size() == 0) {
                    _pendingFlush.remove(flushInterval);
                    _tt.remove(flushInterval).cancel();
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            public synchronized void stop(Flusher flusher, long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                pending.remove(flusher);
                if (pending.size() == 0) {
                    _pendingFlush.remove(flushInterval);
                    _tt.remove(flushInterval).cancel();
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            public synchronized void stop(Flusher flusher, long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                pending.remove(flusher);
                if (pending.size() == 0) {
                    _pendingFlush.remove(flushInterval);
                    _tt.remove(flushInterval).cancel();
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
                                                                                      {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
                                                                                      {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [regular_node]kleene replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
            public synchronized void stop(Flusher flusher, long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                pending.remove(flusher);
                if (pending.size() == 0) {
                    _pendingFlush.remove(flushInterval);
                    _tt.remove(flushInterval).cancel();
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
            public synchronized void stop(Flusher flusher, long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                pending.remove(flusher);
                if (pending.size() == 0) {
                    _pendingFlush.remove(flushInterval);
                    _tt.remove(flushInterval).cancel();
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 12
------------------------------------------------------------


================The best program is updated.================

token count change 451 -> 445
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 52 from 451 to 445
------------------------------------------------------------


=================Reducing node 58, size=445=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
            public synchronized void stop(Flusher flusher, long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                pending.remove(flusher);
                if (pending.size() == 0) {
                    _pendingFlush.remove(flushInterval);
                    _tt.remove(flushInterval).cancel();
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@7
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@3
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 3
------------------------------------------------------------


================The best program is updated.================

token count change 445 -> 382
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@2
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@4
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@2
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@2
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 58 from 445 to 382
------------------------------------------------------------


=================Reducing node 2, size=382==================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    import java.util.concurrent.atomic.AtomicLong;
    import java.util.concurrent.atomic.AtomicReference;
    import java.util.concurrent.locks.ReentrantLock;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@15
    --file: Test.java--
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@7
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@3
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    import java.util.concurrent.atomic.AtomicBoolean;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 13
------------------------------------------------------------


================The best program is updated.================

token count change 382 -> 349
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@4
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@2
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 3
------------------------------------------------------------


================The best program is updated.================

token count change 349 -> 338
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@2
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ConcurrentHashMap;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 4
------------------------------------------------------------


================The best program is updated.================

token count change 338 -> 329
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@8
    --file: Test.java--
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@4
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@2
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 4
------------------------------------------------------------


================The best program is updated.================

token count change 329 -> 320
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@2
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Timer;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Map;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@4
    --file: Test.java--
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@2
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 7
------------------------------------------------------------


================The best program is updated.================

token count change 320 -> 313
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@2
    --file: Test.java--
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 3
------------------------------------------------------------


================The best program is updated.================

token count change 313 -> 306
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 2 from 382 to 306
------------------------------------------------------------


================Reducing node 602, size=306=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
                                     {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
                                     {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
                                                                                      {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
                                                                                      {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 602
------------------------------------------------------------


================Reducing node 606, size=306=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval)
                                     {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval)
                                     {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 606
------------------------------------------------------------


================Reducing node 608, size=306=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__block_1]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 608
------------------------------------------------------------


================Reducing node 610, size=306=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
                pending.add(flusher);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=610}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_plus:blockStatements]remove whole except first
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_plus:blockStatements]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 8
------------------------------------------------------------


================The best program is updated.================

token count change 306 -> 299
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_plus:blockStatements]dd@2
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_plus:blockStatements]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_plus:blockStatements]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 610 from 306 to 299
------------------------------------------------------------


================Reducing node 651, size=299=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                if (pending == null) {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=651}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    pending = new ArrayList<>();
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    pending = new ArrayList<>();
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    _pendingFlush.put(flushInterval, pending);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    _pendingFlush.put(flushInterval, pending);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    _tt.put(flushInterval, t);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    _tt.put(flushInterval, t);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    _timer.schedule(t, flushInterval, flushInterval);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    _timer.schedule(t, flushInterval, flushInterval);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Test script execution is cancelled.=============

It took less than 1 second to cancel the task.

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Test script execution is cancelled.=============

It took less than 1 second to cancel the task.

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                                     {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                                     {
                    pending = new ArrayList<>();
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
                    _pendingFlush.put(flushInterval, pending);
                    _timer.schedule(t, flushInterval, flushInterval);
                    _tt.put(flushInterval, t);
                }
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 10
------------------------------------------------------------


================The best program is updated.================

token count change 299 -> 253
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 651 from 299 to 253
------------------------------------------------------------


================Reducing node 369, size=253=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                   {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                   {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                                                   {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                                                   {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 369
------------------------------------------------------------


================Reducing node 373, size=253=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval)
                                   {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval)
                                   {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 373
------------------------------------------------------------


================Reducing node 375, size=253=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
                ArrayList<Flusher> tasks = _pendingFlush.get(flushInterval);
                if (tasks != null) {
                    for (Flusher f: tasks) {
                        _exec.submit(f);
                    }
                }
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star:optional__block_1]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 5
------------------------------------------------------------


================The best program is updated.================

token count change 253 -> 216
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 375 from 253 to 216
------------------------------------------------------------


================Reducing node 1308, size=216================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private ThreadPoolExecutor _exec = new ThreadPoolExecutor(1, 100, 10, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1024), new ThreadPoolExecutor.DiscardPolicy());
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 1
------------------------------------------------------------


================The best program is updated.================

token count change 216 -> 182
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 1308 from 216 to 182
------------------------------------------------------------


================Reducing node 863, size=182=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 863
------------------------------------------------------------


================Reducing node 864, size=182=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 864
------------------------------------------------------------


================Reducing node 868, size=182=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t
                     ;
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t
                     ;
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask         TimerTask
                     ;
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask         TimerTask
                     ;
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 868
------------------------------------------------------------


================Reducing node 870, size=182=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__variableDeclarator_2]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t
                     ;
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t
                     ;
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 870
------------------------------------------------------------


================Reducing node 871, size=182=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=871}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 871
------------------------------------------------------------


================Reducing node 893, size=182=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t =     TimerTask
                     ;
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t =     TimerTask
                     ;
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 893
------------------------------------------------------------


================Reducing node 1228, size=182================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1228
------------------------------------------------------------


================Reducing node 1159, size=182================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            private HashMap<Long, TimerTask> _tt = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 7
------------------------------------------------------------


================The best program is updated.================

token count change 182 -> 166
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 1159 from 182 to 166
------------------------------------------------------------


================Reducing node 897, size=166=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__enumConstant_5]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask()
                     ;
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask()
                     ;
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 897
------------------------------------------------------------


================Reducing node 898, size=166=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=898}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 898
------------------------------------------------------------


================Reducing node 900, size=166=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@1
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 900
------------------------------------------------------------


================Reducing node 903, size=166=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=903}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                                          {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                                          {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 903
------------------------------------------------------------


=================Reducing node 18, size=166=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
                              {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
                              {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]kleene replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
            public void run() {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
            public void run() {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
            public void run() {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
            public void run() {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 18
------------------------------------------------------------


================Reducing node 1046, size=166================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                ArrayList<Flusher> pending = _pendingFlush.get(flushInterval);
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 8
------------------------------------------------------------


================The best program is updated.================

token count change 166 -> 153
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 1046 from 166 to 153
------------------------------------------------------------


================Reducing node 1543, size=153================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private Timer _timer = new Timer("disruptor-flush-trigger", true);
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 1
------------------------------------------------------------


================The best program is updated.================

token count change 153 -> 141
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 1543 from 153 to 141
------------------------------------------------------------


================Reducing node 604, size=141=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 604
------------------------------------------------------------


================Reducing node 1851, size=141================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 1
------------------------------------------------------------


================The best program is updated.================

token count change 141 -> 132
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 1851 from 141 to 132
------------------------------------------------------------


================Reducing node 1800, size=132================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.ThreadPoolExecutor;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 1
------------------------------------------------------------


================The best program is updated.================

token count change 132 -> 123
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 1800 from 132 to 123
------------------------------------------------------------


================Reducing node 1783, size=123================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    import java.util.concurrent.TimeUnit;
    public class Test {
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    public class Test {
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    public class Test {
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 1
------------------------------------------------------------


================The best program is updated.================

token count change 123 -> 114
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 1783 from 123 to 114
------------------------------------------------------------


================Reducing node 1273, size=114================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    public class Test {
            private HashMap<Long, ArrayList<Flusher>> _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    public class Test {
            private         Long                      _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    public class Test {
            private         Long                      _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    public class Test {
            private HashMap                           _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    public class Test {
            private HashMap                           _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 2
------------------------------------------------------------


================The best program is updated.================

token count change 114 -> 106
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 1273 from 114 to 106
------------------------------------------------------------


================Reducing node 1124, size=106================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    public class Test {
            private HashMap                           _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1124
------------------------------------------------------------


=================Reducing node 23, size=106=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    public class Test {
            private HashMap                           _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 23
------------------------------------------------------------


================Reducing node 1233, size=106================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    public class Test {
            private HashMap                           _pendingFlush = new HashMap<>();
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Test script execution is cancelled.=============

It took less than 1 second to cancel the task.

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    public class Test {
            private HashMap                           _pendingFlush                  ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    public class Test {
            private HashMap                           _pendingFlush                  ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 2
------------------------------------------------------------


================The best program is updated.================

token count change 106 -> 99
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 1233 from 106 to 99
------------------------------------------------------------


================Reducing node 1938, size=99=================

The current best program is the following

    --file: Test.java--
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 1
------------------------------------------------------------


================The best program is updated.================

token count change 99 -> 92
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 1938 from 99 to 92
------------------------------------------------------------


================Reducing node 1910, size=92=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.Timer;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.Timer;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1910
------------------------------------------------------------


================Reducing node 1882, size=92=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.Timer;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 2
------------------------------------------------------------


================The best program is updated.================

token count change 92 -> 85
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 1882 from 92 to 85
------------------------------------------------------------


================Reducing node 1868, size=85=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.HashMap;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1868
------------------------------------------------------------


=================Reducing node 907, size=85=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 907
------------------------------------------------------------


=================Reducing node 25, size=85==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 25
------------------------------------------------------------


=================Reducing node 28, size=85==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=28}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
                              {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
                              {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 28
------------------------------------------------------------


================Reducing node 1127, size=85=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__methodDeclarator_1]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                                         ) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                                         ) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1127
------------------------------------------------------------


================Reducing node 1130, size=85=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher, final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=1130}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher                          ) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(Flusher flusher                          ) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 6
------------------------------------------------------------


================The best program is updated.================

token count change 85 -> 82
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 1130 from 85 to 82
------------------------------------------------------------


=================Reducing node 371, size=82=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 371
------------------------------------------------------------


================Reducing node 1912, size=82=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java             ;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java             ;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import           HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import           HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1912
------------------------------------------------------------


================Reducing node 1870, size=82=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.HashMap;
    import           TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import           TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.HashMap;
    import java               ;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java               ;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1870
------------------------------------------------------------


=================Reducing node 909, size=82=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__block_1]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 909
------------------------------------------------------------


=================Reducing node 911, size=82=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=911}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 911
------------------------------------------------------------


=================Reducing node 915, size=82=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 915
------------------------------------------------------------


=================Reducing node 583, size=82=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 583
------------------------------------------------------------


================Reducing node 1914, size=82=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__typeName_2]dd@1
    --file: Test.java--
    import           HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import           HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1914
------------------------------------------------------------


================Reducing node 1916, size=82=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=1916}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1916
------------------------------------------------------------


================Reducing node 1872, size=82=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__typeName_2]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import           TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import           TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1872
------------------------------------------------------------


================Reducing node 1874, size=82=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=1874}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1874
------------------------------------------------------------


=================Reducing node 918, size=82=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 918
------------------------------------------------------------


=================Reducing node 905, size=82=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 905
------------------------------------------------------------


=================Reducing node 30, size=82==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 30
------------------------------------------------------------


================Reducing node 1917, size=82=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java     .HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java     .HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import      util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import      util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1917
------------------------------------------------------------


================Reducing node 1875, size=82=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.HashMap;
    import      util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import      util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.HashMap;
    import java     .TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java     .TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1875
------------------------------------------------------------


================Reducing node 1133, size=82=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                                         ) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                                         ) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1133
------------------------------------------------------------


=================Reducing node 948, size=82=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 948
------------------------------------------------------------


=================Reducing node 921, size=82=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 921
------------------------------------------------------------


=================Reducing node 904, size=82=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__methodDeclaration_1]dd@2
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                               void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                               void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__methodDeclaration_1]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                               void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        @Override
                               void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star:kleene_star__methodDeclaration_1]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 16
------------------------------------------------------------


================The best program is updated.================

token count change 82 -> 80
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 904 from 82 to 80
------------------------------------------------------------


=================Reducing node 36, size=80==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 36
------------------------------------------------------------


================Reducing node 1920, size=80=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__packageName_1]dd@1
    --file: Test.java--
    import java     .HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java     .HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1920
------------------------------------------------------------


================Reducing node 1921, size=80=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=1921}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1921
------------------------------------------------------------


================Reducing node 1878, size=80=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__packageName_1]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java     .TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java     .TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1878
------------------------------------------------------------


================Reducing node 1879, size=80=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=1879}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1879
------------------------------------------------------------


=================Reducing node 961, size=80=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 961
------------------------------------------------------------


=================Reducing node 603, size=80=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
            public synchronized void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star:kleene_star__methodDeclaration_1]dd@2
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 3
------------------------------------------------------------


================The best program is updated.================

token count change 80 -> 78
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 603 from 80 to 78
------------------------------------------------------------


=================Reducing node 586, size=78=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__methodDeclarator_1]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(                 ) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(                 ) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 586
------------------------------------------------------------


=================Reducing node 591, size=78=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=591}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 591
------------------------------------------------------------


=================Reducing node 370, size=78=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
            private synchronized void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star:kleene_star__methodDeclaration_1]dd@2
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 2
------------------------------------------------------------


================The best program is updated.================

token count change 78 -> 76
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 370 from 78 to 76
------------------------------------------------------------


=================Reducing node 32, size=76==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 32
------------------------------------------------------------


=================Reducing node 22, size=76==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher implements Runnable {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star:optional__normalClassDeclaration_4]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 1
------------------------------------------------------------


================The best program is updated.================

token count change 76 -> 74
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 22 from 76 to 74
------------------------------------------------------------


================Reducing node 1923, size=74=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1923
------------------------------------------------------------


================Reducing node 1922, size=74=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1922
------------------------------------------------------------


================Reducing node 1919, size=74=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1919
------------------------------------------------------------


================Reducing node 1918, size=74=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1918
------------------------------------------------------------


================Reducing node 1915, size=74=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1915
------------------------------------------------------------


================Reducing node 1913, size=74=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1913
------------------------------------------------------------


================Reducing node 1911, size=74=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1911
------------------------------------------------------------


================Reducing node 1881, size=74=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1881
------------------------------------------------------------


================Reducing node 1880, size=74=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1880
------------------------------------------------------------


================Reducing node 1877, size=74=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1877
------------------------------------------------------------


================Reducing node 1876, size=74=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1876
------------------------------------------------------------


================Reducing node 1873, size=74=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1873
------------------------------------------------------------


================Reducing node 1871, size=74=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1871
------------------------------------------------------------


================Reducing node 1869, size=74=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1869
------------------------------------------------------------


================Reducing node 1274, size=74=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1274
------------------------------------------------------------


================Reducing node 1269, size=74=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1269
------------------------------------------------------------


================Reducing node 1232, size=74=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1232
------------------------------------------------------------


================Reducing node 1229, size=74=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
            private HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star:kleene_star__fieldDeclaration_1]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 1
------------------------------------------------------------


================The best program is updated.================

token count change 74 -> 73
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 1229 from 74 to 73
------------------------------------------------------------


================Reducing node 1154, size=73=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1154
------------------------------------------------------------


================Reducing node 1139, size=73=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1139
------------------------------------------------------------


================Reducing node 1137, size=73=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1137
------------------------------------------------------------


================Reducing node 1134, size=73=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                 final long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star:kleene_star__lastFormalParameter_1]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 1
------------------------------------------------------------


================The best program is updated.================

token count change 73 -> 72
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 1134 from 73 to 72
------------------------------------------------------------


================Reducing node 1128, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1128
------------------------------------------------------------


================Reducing node 1126, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1126
------------------------------------------------------------


================Reducing node 1125, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1125
------------------------------------------------------------


=================Reducing node 968, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 968
------------------------------------------------------------


=================Reducing node 964, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 964
------------------------------------------------------------


=================Reducing node 963, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 963
------------------------------------------------------------


=================Reducing node 962, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 962
------------------------------------------------------------


=================Reducing node 955, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 955
------------------------------------------------------------


=================Reducing node 952, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 952
------------------------------------------------------------


=================Reducing node 951, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 951
------------------------------------------------------------


=================Reducing node 950, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 950
------------------------------------------------------------


=================Reducing node 949, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 949
------------------------------------------------------------


=================Reducing node 946, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 946
------------------------------------------------------------


=================Reducing node 924, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__explicitConstructorInvocation_2]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(             );
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(             );
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 924
------------------------------------------------------------


=================Reducing node 944, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 944
------------------------------------------------------------


=================Reducing node 923, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 923
------------------------------------------------------------


=================Reducing node 920, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 920
------------------------------------------------------------


=================Reducing node 917, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 917
------------------------------------------------------------


=================Reducing node 910, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 910
------------------------------------------------------------


=================Reducing node 908, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 908
------------------------------------------------------------


=================Reducing node 901, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 901
------------------------------------------------------------


=================Reducing node 899, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 899
------------------------------------------------------------


=================Reducing node 896, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 896
------------------------------------------------------------


=================Reducing node 895, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 895
------------------------------------------------------------


=================Reducing node 872, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 872
------------------------------------------------------------


=================Reducing node 865, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 865
------------------------------------------------------------


=================Reducing node 609, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 609
------------------------------------------------------------


=================Reducing node 607, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 607
------------------------------------------------------------


=================Reducing node 597, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 597
------------------------------------------------------------


=================Reducing node 596, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 596
------------------------------------------------------------


=================Reducing node 594, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 594
------------------------------------------------------------


=================Reducing node 587, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 587
------------------------------------------------------------


=================Reducing node 585, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 585
------------------------------------------------------------


=================Reducing node 584, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 584
------------------------------------------------------------


=================Reducing node 376, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 376
------------------------------------------------------------


=================Reducing node 374, size=72=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 374
------------------------------------------------------------


=================Reducing node 40, size=72==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 40
------------------------------------------------------------


=================Reducing node 39, size=72==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 39
------------------------------------------------------------


=================Reducing node 38, size=72==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 38
------------------------------------------------------------


=================Reducing node 37, size=72==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 37
------------------------------------------------------------


=================Reducing node 34, size=72==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 34
------------------------------------------------------------


=================Reducing node 33, size=72==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 33
------------------------------------------------------------


=================Reducing node 29, size=72==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
            public void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star:kleene_star__methodDeclaration_1]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
                   void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
                   void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 2
------------------------------------------------------------


================The best program is updated.================

token count change 72 -> 71
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 29 from 72 to 71
------------------------------------------------------------


=================Reducing node 26, size=71==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
                   void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 26
------------------------------------------------------------


=================Reducing node 24, size=71==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
                   void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 24
------------------------------------------------------------


=================Reducing node 21, size=71==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
                   void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 21
------------------------------------------------------------


=================Reducing node 20, size=71==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
                   void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 20
------------------------------------------------------------


=================Reducing node 19, size=71==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
        private class Flusher                     {
                   void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star:kleene_star__normalClassDeclaration_1]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
                class Flusher                     {
                   void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
                class Flusher                     {
                   void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 1
------------------------------------------------------------


================The best program is updated.================

token count change 71 -> 70
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 19 from 71 to 70
------------------------------------------------------------


=================Reducing node 13, size=70==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
                class Flusher                     {
                   void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 13
------------------------------------------------------------


=================Reducing node 11, size=70==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
                class Flusher                     {
                   void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 11
------------------------------------------------------------


==================Reducing node 9, size=70==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
                class Flusher                     {
                   void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 9
------------------------------------------------------------


==================Reducing node 8, size=70==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
                class Flusher                     {
                   void run() {
            }
        }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 8
------------------------------------------------------------


==================Reducing node 7, size=70==================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    public class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
                class Flusher                     {
                   void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star:kleene_star__normalClassDeclaration_1]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
                class Flusher                     {
                   void run() {
            }
        }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
                class Flusher                     {
                   void run() {
            }
        }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 1
------------------------------------------------------------


================The best program is updated.================

token count change 70 -> 69
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 7 from 70 to 69
------------------------------------------------------------


Rebuilding spar-tree: The spartree is rebuilt.

=Fixpoint iteration 2. Reducer: perses_node_priority_with_dfs_delta

The spar-tree is the following.
compilationUnit {id=1953,slot_type=compilationUnit}
|___(*) {id=1954,slot_type=kleene_star__compilationUnit_2}
|   |___singleTypeImportDeclaration {id=2164,slot_type=[importDeclaration,singleTypeImportDeclaration]}
|   |   |___Token:import {id=2165,slot_type=IMPORT}
|   |   |___typeName {id=2166,slot_type=typeName}
|   |   |   |___(?) {id=2168,slot_type=optional__typeName_2}
|   |   |   |   |___aux_rule__typeName_1 {id=2170,slot_type=aux_rule__typeName_1}
|   |   |   |       |___packageName {id=2171,slot_type=packageName}
|   |   |   |       |   |___Token:java {id=2173,slot_type=Identifier}
|   |   |   |       |   |___(*) {id=2174,slot_type=kleene_star__packageName_1}
|   |   |   |       |       |___aux_rule__packageName_2 {id=2175,slot_type=aux_rule__packageName_2}
|   |   |   |       |           |___Token:. {id=2176,slot_type=DOT}
|   |   |   |       |           |___Token:util {id=2177,slot_type=Identifier}
|   |   |   |       |___Token:. {id=2172,slot_type=DOT}
|   |   |   |___Token:HashMap {id=2169,slot_type=Identifier}
|   |   |___Token:; {id=2167,slot_type=SEMI}
|   |___singleTypeImportDeclaration {id=2150,slot_type=[importDeclaration,singleTypeImportDeclaration]}
|       |___Token:import {id=2151,slot_type=IMPORT}
|       |___typeName {id=2152,slot_type=typeName}
|       |   |___(?) {id=2154,slot_type=optional__typeName_2}
|       |   |   |___aux_rule__typeName_1 {id=2156,slot_type=aux_rule__typeName_1}
|       |   |       |___packageName {id=2157,slot_type=packageName}
|       |   |       |   |___Token:java {id=2159,slot_type=Identifier}
|       |   |       |   |___(*) {id=2160,slot_type=kleene_star__packageName_1}
|       |   |       |       |___aux_rule__packageName_2 {id=2161,slot_type=aux_rule__packageName_2}
|       |   |       |           |___Token:. {id=2162,slot_type=DOT}
|       |   |       |           |___Token:util {id=2163,slot_type=Identifier}
|       |   |       |___Token:. {id=2158,slot_type=DOT}
|       |   |___Token:TimerTask {id=2155,slot_type=Identifier}
|       |___Token:; {id=2153,slot_type=SEMI}
|___(*) {id=1955,slot_type=kleene_star__compilationUnit_3}
    |___normalClassDeclaration {id=1958,slot_type=[typeDeclaration,classDeclaration,normalClassDeclaration]}
        |___Token:class {id=1959,slot_type=CLASS}
        |___Token:Test {id=1960,slot_type=Identifier}
        |___classBody {id=1961,slot_type=classBody}
            |___Token:{ {id=1962,slot_type=LBRACE}
            |___(*) {id=1963,slot_type=kleene_star__classBody_1}
            |   |___fieldDeclaration {id=2137,slot_type=[classBodyDeclaration,fieldDeclaration]}
            |   |   |___Token:HashMap {id=2147,slot_type=[unannType,unannClassOrInterfaceType,altnt_block__unannClassOrInterfaceType_3,unannClassType_lfno_unannClassOrInterfaceType,Identifier]}
            |   |   |___Token:HashMap {id=2143,slot_type=[variableDeclaratorList,variableDeclarator,variableDeclaratorId,Identifier]}
            |   |   |___Token:; {id=2140,slot_type=SEMI}
            |   |___methodDeclaration {id=2012,slot_type=[classBodyDeclaration,methodDeclaration]}
            |   |   |___methodHeader {id=2013,slot_type=methodHeader}
            |   |   |   |___Token:void {id=2136,slot_type=[result,VOID]}
            |   |   |   |___methodDeclarator {id=2122,slot_type=methodDeclarator}
            |   |   |       |___Token:start {id=2123,slot_type=Identifier}
            |   |   |       |___Token:( {id=2124,slot_type=LPAREN}
            |   |   |       |___(?) {id=2125,slot_type=optional__methodDeclarator_1}
            |   |   |       |   |___formalParameter {id=2130,slot_type=[formalParameterList,aux_rule__formalParameterList_3,lastFormalParameter,formalParameter]}
            |   |   |       |       |___Token:long {id=2135,slot_type=[unannType,altnt_block__primitiveType_3,LONG]}
            |   |   |       |       |___Token:flushInterval {id=2133,slot_type=[variableDeclaratorId,Identifier]}
            |   |   |       |___Token:) {id=2126,slot_type=RPAREN}
            |   |   |___block {id=2015,slot_type=[methodBody,block]}
            |   |       |___Token:{ {id=2016,slot_type=LBRACE}
            |   |       |___(?) {id=2017,slot_type=optional__block_1}
            |   |       |   |___(+) {id=2019,slot_type=blockStatements}
            |   |       |       |___localVariableDeclarationStatement {id=2021,slot_type=[blockStatement,localVariableDeclarationStatement]}
            |   |       |           |___localVariableDeclaration {id=2022,slot_type=localVariableDeclaration}
            |   |       |           |   |___Token:TimerTask {id=2120,slot_type=[unannType,unannClassOrInterfaceType,altnt_block__unannClassOrInterfaceType_3,unannClassType_lfno_unannClassOrInterfaceType,Identifier]}
            |   |       |           |   |___variableDeclarator {id=2026,slot_type=[variableDeclaratorList,variableDeclarator]}
            |   |       |           |       |___Token:t {id=2116,slot_type=[variableDeclaratorId,Identifier]}
            |   |       |           |       |___(?) {id=2028,slot_type=optional__variableDeclarator_2}
            |   |       |           |           |___aux_rule__variableDeclarator_1 {id=2029,slot_type=aux_rule__variableDeclarator_1}
            |   |       |           |               |___Token:= {id=2030,slot_type=ASSIGN}
            |   |       |           |               |___classInstanceCreationExpression_lfno_primary {id=2051,slot_type=[variableInitializer,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,classInstanceCreationExpression_lfno_primary]}
            |   |       |           |                   |___aux_rule__classInstanceCreationExpression_lfno_primary_15 {id=2113,slot_type=[altnt_block__classInstanceCreationExpression_lfno_primary_14,aux_rule__classInstanceCreationExpression_lfno_primary_15]}
            |   |       |           |                   |   |___Token:new {id=2114,slot_type=NEW}
            |   |       |           |                   |   |___Token:TimerTask {id=2115,slot_type=Identifier}
            |   |       |           |                   |___Token:( {id=2053,slot_type=LPAREN}
            |   |       |           |                   |___Token:) {id=2054,slot_type=RPAREN}
            |   |       |           |                   |___(?) {id=2055,slot_type=optional__enumConstant_5}
            |   |       |           |                       |___classBody {id=2056,slot_type=classBody}
            |   |       |           |                           |___Token:{ {id=2057,slot_type=LBRACE}
            |   |       |           |                           |___(*) {id=2058,slot_type=kleene_star__classBody_1}
            |   |       |           |                           |   |___methodDeclaration {id=2061,slot_type=[classBodyDeclaration,methodDeclaration]}
            |   |       |           |                           |       |___(*) {id=2062,slot_type=kleene_star__methodDeclaration_1}
            |   |       |           |                           |       |   |___Token:public {id=2112,slot_type=[methodModifier,PUBLIC]}
            |   |       |           |                           |       |___methodHeader {id=2063,slot_type=methodHeader}
            |   |       |           |                           |       |   |___Token:void {id=2110,slot_type=[result,VOID]}
            |   |       |           |                           |       |   |___methodDeclarator {id=2106,slot_type=methodDeclarator}
            |   |       |           |                           |       |       |___Token:run {id=2107,slot_type=Identifier}
            |   |       |           |                           |       |       |___Token:( {id=2108,slot_type=LPAREN}
            |   |       |           |                           |       |       |___Token:) {id=2109,slot_type=RPAREN}
            |   |       |           |                           |       |___block {id=2065,slot_type=[methodBody,block]}
            |   |       |           |                           |           |___Token:{ {id=2066,slot_type=LBRACE}
            |   |       |           |                           |           |___(?) {id=2067,slot_type=optional__block_1}
            |   |       |           |                           |           |   |___(+) {id=2069,slot_type=blockStatements}
            |   |       |           |                           |           |       |___expressionStatement {id=2073,slot_type=[blockStatement,statement,statementWithoutTrailingSubstatement,expressionStatement]}
            |   |       |           |                           |           |           |___methodInvocation {id=2076,slot_type=[statementExpression,methodInvocation]}
            |   |       |           |                           |           |           |   |___aux_rule__methodInvocation_19 {id=2079,slot_type=[altnt_block__methodInvocation_12,aux_rule__methodInvocation_19]}
            |   |       |           |                           |           |           |   |   |___Token:invokeAll {id=2104,slot_type=[altnt_block__methodInvocation_16,methodName,Identifier]}
            |   |       |           |                           |           |           |   |   |___Token:( {id=2081,slot_type=LPAREN}
            |   |       |           |                           |           |           |   |   |___(?) {id=2082,slot_type=optional__explicitConstructorInvocation_2}
            |   |       |           |                           |           |           |   |       |___Token:flushInterval {id=2102,slot_type=[argumentList,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,typeName,Identifier]}
            |   |       |           |                           |           |           |   |___Token:) {id=2078,slot_type=RPAREN}
            |   |       |           |                           |           |           |___Token:; {id=2075,slot_type=SEMI}
            |   |       |           |                           |           |___Token:} {id=2068,slot_type=RBRACE}
            |   |       |           |                           |___Token:} {id=2059,slot_type=RBRACE}
            |   |       |           |___Token:; {id=2023,slot_type=SEMI}
            |   |       |___Token:} {id=2018,slot_type=RBRACE}
            |   |___methodDeclaration {id=1990,slot_type=[classBodyDeclaration,methodDeclaration]}
            |   |   |___methodHeader {id=1991,slot_type=methodHeader}
            |   |   |   |___Token:void {id=2011,slot_type=[result,VOID]}
            |   |   |   |___methodDeclarator {id=1997,slot_type=methodDeclarator}
            |   |   |       |___Token:invokeAll {id=1998,slot_type=Identifier}
            |   |   |       |___Token:( {id=1999,slot_type=LPAREN}
            |   |   |       |___(?) {id=2000,slot_type=optional__methodDeclarator_1}
            |   |   |       |   |___formalParameter {id=2005,slot_type=[formalParameterList,aux_rule__formalParameterList_3,lastFormalParameter,formalParameter]}
            |   |   |       |       |___Token:int {id=2010,slot_type=[unannType,altnt_block__primitiveType_3,INT]}
            |   |   |       |       |___Token:flushInterval {id=2008,slot_type=[variableDeclaratorId,Identifier]}
            |   |   |       |___Token:) {id=2001,slot_type=RPAREN}
            |   |   |___block {id=1993,slot_type=[methodBody,block]}
            |   |       |___Token:{ {id=1994,slot_type=LBRACE}
            |   |       |___Token:} {id=1995,slot_type=RBRACE}
            |   |___normalClassDeclaration {id=1970,slot_type=[classBodyDeclaration,classDeclaration,normalClassDeclaration]}
            |       |___Token:class {id=1971,slot_type=CLASS}
            |       |___Token:Flusher {id=1972,slot_type=Identifier}
            |       |___classBody {id=1973,slot_type=classBody}
            |           |___Token:{ {id=1974,slot_type=LBRACE}
            |           |___(*) {id=1975,slot_type=kleene_star__classBody_1}
            |           |   |___methodDeclaration {id=1978,slot_type=[classBodyDeclaration,methodDeclaration]}
            |           |       |___methodHeader {id=1979,slot_type=methodHeader}
            |           |       |   |___Token:void {id=1989,slot_type=[result,VOID]}
            |           |       |   |___methodDeclarator {id=1985,slot_type=methodDeclarator}
            |           |       |       |___Token:run {id=1986,slot_type=Identifier}
            |           |       |       |___Token:( {id=1987,slot_type=LPAREN}
            |           |       |       |___Token:) {id=1988,slot_type=RPAREN}
            |           |       |___block {id=1981,slot_type=[methodBody,block]}
            |           |           |___Token:{ {id=1982,slot_type=LBRACE}
            |           |           |___Token:} {id=1983,slot_type=RBRACE}
            |           |___Token:} {id=1976,slot_type=RBRACE}
            |___Token:} {id=1964,slot_type=RBRACE}
------------------------------------------------------------


================Reducing node 1955, size=69=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
                class Flusher                     {
                   void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_3]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1955
------------------------------------------------------------


================Reducing node 1958, size=69=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
                class Flusher                     {
                   void run() {
            }
        }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=1958}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
                class Flusher                     {
                   void run() {
            }
        }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
                class Flusher                     {
                   void run() {
            }
        }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1958
------------------------------------------------------------


================Reducing node 1961, size=69=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
                class Flusher                     {
                   void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test
                                                  {
                   void run() {
            }
        }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test
                                                  {
                   void run() {
            }
        }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1961
------------------------------------------------------------


================Reducing node 1963, size=69=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
                class Flusher                     {
                   void run() {
            }
        }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@4
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@2
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 6
------------------------------------------------------------


================The best program is updated.================

token count change 69 -> 59
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                    HashMap                                               HashMap    ;
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@2
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                    HashMap                                               HashMap    ;
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                    HashMap                                               HashMap    ;
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 4
------------------------------------------------------------


================The best program is updated.================

token count change 59 -> 56
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 1963 from 69 to 56
------------------------------------------------------------


================Reducing node 2012, size=56=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                                                                      {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                                                                      {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2012
------------------------------------------------------------


================Reducing node 2015, size=56=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2015
------------------------------------------------------------


================Reducing node 2017, size=56=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__block_1]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2017
------------------------------------------------------------


================Reducing node 2019, size=56=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=2019}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2019
------------------------------------------------------------


================Reducing node 2021, size=56=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2021
------------------------------------------------------------


================Reducing node 2022, size=56=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2022
------------------------------------------------------------


================Reducing node 2026, size=56=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t
                     ;
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t
                     ;
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask         TimerTask
                     ;
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask         TimerTask
                     ;
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2026
------------------------------------------------------------


================Reducing node 2028, size=56=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__variableDeclarator_2]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t
                     ;
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t
                     ;
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2028
------------------------------------------------------------


================Reducing node 2029, size=56=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=2029}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2029
------------------------------------------------------------


================Reducing node 2051, size=56=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t =     TimerTask
                     ;
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t =     TimerTask
                     ;
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2051
------------------------------------------------------------


================Reducing node 2055, size=56=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__enumConstant_5]dd@1
    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask()
                     ;
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask()
                     ;
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2055
------------------------------------------------------------


================Reducing node 2056, size=56=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=2056}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2056
------------------------------------------------------------


================Reducing node 1954, size=56=================

The current best program is the following

    --file: Test.java--
    import java.util.HashMap;
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@2
    --file: Test.java--
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@1
    --file: Test.java--
    import java.util.HashMap;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.HashMap;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@1
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

0 entries are removed: 0 --> 0.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 12
------------------------------------------------------------


================The best program is updated.================

token count change 56 -> 49
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 1954 from 56 to 49
------------------------------------------------------------


================Reducing node 2058, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@1
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2058
------------------------------------------------------------


================Reducing node 2061, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=2061}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                                          {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                                          {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2061
------------------------------------------------------------


================Reducing node 1990, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                                                   {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                                                   {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1990
------------------------------------------------------------


================Reducing node 2150, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2150
------------------------------------------------------------


================Reducing node 2065, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2065
------------------------------------------------------------


================Reducing node 2013, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2013
------------------------------------------------------------


================Reducing node 1991, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1991
------------------------------------------------------------


================Reducing node 2152, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import           TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import           TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java               ;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java               ;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2152
------------------------------------------------------------


================Reducing node 2122, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2122
------------------------------------------------------------


================Reducing node 2067, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__block_1]dd@1
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2067
------------------------------------------------------------


================Reducing node 2069, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=2069}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2069
------------------------------------------------------------


================Reducing node 2073, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2073
------------------------------------------------------------


================Reducing node 1997, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1997
------------------------------------------------------------


================Reducing node 2154, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__typeName_2]dd@1
    --file: Test.java--
    import           TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import           TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2154
------------------------------------------------------------


================Reducing node 2156, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=2156}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2156
------------------------------------------------------------


================Reducing node 2076, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2076
------------------------------------------------------------


================Reducing node 2063, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2063
------------------------------------------------------------


================Reducing node 2157, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java     .TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java     .TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import      util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import      util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2157
------------------------------------------------------------


================Reducing node 2106, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2106
------------------------------------------------------------


================Reducing node 2079, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2079
------------------------------------------------------------


================Reducing node 2160, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__packageName_1]dd@1
    --file: Test.java--
    import java     .TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java     .TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2160
------------------------------------------------------------


================Reducing node 2161, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=2161}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2161
------------------------------------------------------------


================Reducing node 2125, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__methodDeclarator_1]dd@1
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                                         ) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                                         ) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2125
------------------------------------------------------------


================Reducing node 2130, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=2130}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2130
------------------------------------------------------------


================Reducing node 2113, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2113
------------------------------------------------------------


================Reducing node 2000, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__methodDeclarator_1]dd@1
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(                 ) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(                 ) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2000
------------------------------------------------------------


================Reducing node 2005, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=2005}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2005
------------------------------------------------------------


================Reducing node 1993, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1993
------------------------------------------------------------


================Reducing node 2163, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2163
------------------------------------------------------------


================Reducing node 2162, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2162
------------------------------------------------------------


================Reducing node 2159, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2159
------------------------------------------------------------


================Reducing node 2158, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2158
------------------------------------------------------------


================Reducing node 2155, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2155
------------------------------------------------------------


================Reducing node 2153, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2153
------------------------------------------------------------


================Reducing node 2151, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2151
------------------------------------------------------------


================Reducing node 2136, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2136
------------------------------------------------------------


================Reducing node 2135, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2135
------------------------------------------------------------


================Reducing node 2133, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2133
------------------------------------------------------------


================Reducing node 2126, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2126
------------------------------------------------------------


================Reducing node 2124, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2124
------------------------------------------------------------


================Reducing node 2123, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2123
------------------------------------------------------------


================Reducing node 2120, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2120
------------------------------------------------------------


================Reducing node 2116, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2116
------------------------------------------------------------


================Reducing node 2115, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2115
------------------------------------------------------------


================Reducing node 2114, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2114
------------------------------------------------------------


================Reducing node 2110, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2110
------------------------------------------------------------


================Reducing node 2109, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2109
------------------------------------------------------------


================Reducing node 2108, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2108
------------------------------------------------------------


================Reducing node 2107, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2107
------------------------------------------------------------


================Reducing node 2104, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2104
------------------------------------------------------------


================Reducing node 2082, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__explicitConstructorInvocation_2]dd@1
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(             );
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(             );
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2082
------------------------------------------------------------


================Reducing node 2102, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2102
------------------------------------------------------------


================Reducing node 2081, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2081
------------------------------------------------------------


================Reducing node 2078, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2078
------------------------------------------------------------


================Reducing node 2075, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2075
------------------------------------------------------------


================Reducing node 2068, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2068
------------------------------------------------------------


================Reducing node 2066, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2066
------------------------------------------------------------


================Reducing node 2062, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__methodDeclaration_1]dd@1
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                               void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                               void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2062
------------------------------------------------------------


================Reducing node 2112, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2112
------------------------------------------------------------


================Reducing node 2059, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2059
------------------------------------------------------------


================Reducing node 2057, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2057
------------------------------------------------------------


================Reducing node 2054, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2054
------------------------------------------------------------


================Reducing node 2053, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2053
------------------------------------------------------------


================Reducing node 2030, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2030
------------------------------------------------------------


================Reducing node 2023, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2023
------------------------------------------------------------


================Reducing node 2018, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2018
------------------------------------------------------------


================Reducing node 2016, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2016
------------------------------------------------------------


================Reducing node 2011, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2011
------------------------------------------------------------


================Reducing node 2010, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2010
------------------------------------------------------------


================Reducing node 2008, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2008
------------------------------------------------------------


================Reducing node 2001, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2001
------------------------------------------------------------


================Reducing node 1999, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1999
------------------------------------------------------------


================Reducing node 1998, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1998
------------------------------------------------------------


================Reducing node 1995, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1995
------------------------------------------------------------


================Reducing node 1994, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1994
------------------------------------------------------------


================Reducing node 1964, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1964
------------------------------------------------------------


================Reducing node 1962, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1962
------------------------------------------------------------


================Reducing node 1960, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1960
------------------------------------------------------------


================Reducing node 1959, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 1959
------------------------------------------------------------


Rebuilding spar-tree: The spartree is rebuilt.

=Fixpoint iteration 3. Reducer: perses_node_priority_with_dfs_delta

The spar-tree is the following.
compilationUnit {id=2179,slot_type=compilationUnit}
|___(*) {id=2180,slot_type=kleene_star__compilationUnit_2}
|   |___singleTypeImportDeclaration {id=2341,slot_type=[importDeclaration,singleTypeImportDeclaration]}
|       |___Token:import {id=2342,slot_type=IMPORT}
|       |___typeName {id=2343,slot_type=typeName}
|       |   |___(?) {id=2345,slot_type=optional__typeName_2}
|       |   |   |___aux_rule__typeName_1 {id=2347,slot_type=aux_rule__typeName_1}
|       |   |       |___packageName {id=2348,slot_type=packageName}
|       |   |       |   |___Token:java {id=2350,slot_type=Identifier}
|       |   |       |   |___(*) {id=2351,slot_type=kleene_star__packageName_1}
|       |   |       |       |___aux_rule__packageName_2 {id=2352,slot_type=aux_rule__packageName_2}
|       |   |       |           |___Token:. {id=2353,slot_type=DOT}
|       |   |       |           |___Token:util {id=2354,slot_type=Identifier}
|       |   |       |___Token:. {id=2349,slot_type=DOT}
|       |   |___Token:TimerTask {id=2346,slot_type=Identifier}
|       |___Token:; {id=2344,slot_type=SEMI}
|___(*) {id=2181,slot_type=kleene_star__compilationUnit_3}
    |___normalClassDeclaration {id=2184,slot_type=[typeDeclaration,classDeclaration,normalClassDeclaration]}
        |___Token:class {id=2185,slot_type=CLASS}
        |___Token:Test {id=2186,slot_type=Identifier}
        |___classBody {id=2187,slot_type=classBody}
            |___Token:{ {id=2188,slot_type=LBRACE}
            |___(*) {id=2189,slot_type=kleene_star__classBody_1}
            |   |___methodDeclaration {id=2215,slot_type=[classBodyDeclaration,methodDeclaration]}
            |   |   |___methodHeader {id=2216,slot_type=methodHeader}
            |   |   |   |___Token:void {id=2339,slot_type=[result,VOID]}
            |   |   |   |___methodDeclarator {id=2325,slot_type=methodDeclarator}
            |   |   |       |___Token:start {id=2326,slot_type=Identifier}
            |   |   |       |___Token:( {id=2327,slot_type=LPAREN}
            |   |   |       |___(?) {id=2328,slot_type=optional__methodDeclarator_1}
            |   |   |       |   |___formalParameter {id=2333,slot_type=[formalParameterList,aux_rule__formalParameterList_3,lastFormalParameter,formalParameter]}
            |   |   |       |       |___Token:long {id=2338,slot_type=[unannType,altnt_block__primitiveType_3,LONG]}
            |   |   |       |       |___Token:flushInterval {id=2336,slot_type=[variableDeclaratorId,Identifier]}
            |   |   |       |___Token:) {id=2329,slot_type=RPAREN}
            |   |   |___block {id=2218,slot_type=[methodBody,block]}
            |   |       |___Token:{ {id=2219,slot_type=LBRACE}
            |   |       |___(?) {id=2220,slot_type=optional__block_1}
            |   |       |   |___(+) {id=2222,slot_type=blockStatements}
            |   |       |       |___localVariableDeclarationStatement {id=2224,slot_type=[blockStatement,localVariableDeclarationStatement]}
            |   |       |           |___localVariableDeclaration {id=2225,slot_type=localVariableDeclaration}
            |   |       |           |   |___Token:TimerTask {id=2323,slot_type=[unannType,unannClassOrInterfaceType,altnt_block__unannClassOrInterfaceType_3,unannClassType_lfno_unannClassOrInterfaceType,Identifier]}
            |   |       |           |   |___variableDeclarator {id=2229,slot_type=[variableDeclaratorList,variableDeclarator]}
            |   |       |           |       |___Token:t {id=2319,slot_type=[variableDeclaratorId,Identifier]}
            |   |       |           |       |___(?) {id=2231,slot_type=optional__variableDeclarator_2}
            |   |       |           |           |___aux_rule__variableDeclarator_1 {id=2232,slot_type=aux_rule__variableDeclarator_1}
            |   |       |           |               |___Token:= {id=2233,slot_type=ASSIGN}
            |   |       |           |               |___classInstanceCreationExpression_lfno_primary {id=2254,slot_type=[variableInitializer,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,primary,altnt_block__primary_2,classInstanceCreationExpression_lfno_primary]}
            |   |       |           |                   |___aux_rule__classInstanceCreationExpression_lfno_primary_15 {id=2316,slot_type=[altnt_block__classInstanceCreationExpression_lfno_primary_14,aux_rule__classInstanceCreationExpression_lfno_primary_15]}
            |   |       |           |                   |   |___Token:new {id=2317,slot_type=NEW}
            |   |       |           |                   |   |___Token:TimerTask {id=2318,slot_type=Identifier}
            |   |       |           |                   |___Token:( {id=2256,slot_type=LPAREN}
            |   |       |           |                   |___Token:) {id=2257,slot_type=RPAREN}
            |   |       |           |                   |___(?) {id=2258,slot_type=optional__enumConstant_5}
            |   |       |           |                       |___classBody {id=2259,slot_type=classBody}
            |   |       |           |                           |___Token:{ {id=2260,slot_type=LBRACE}
            |   |       |           |                           |___(*) {id=2261,slot_type=kleene_star__classBody_1}
            |   |       |           |                           |   |___methodDeclaration {id=2264,slot_type=[classBodyDeclaration,methodDeclaration]}
            |   |       |           |                           |       |___(*) {id=2265,slot_type=kleene_star__methodDeclaration_1}
            |   |       |           |                           |       |   |___Token:public {id=2315,slot_type=[methodModifier,PUBLIC]}
            |   |       |           |                           |       |___methodHeader {id=2266,slot_type=methodHeader}
            |   |       |           |                           |       |   |___Token:void {id=2313,slot_type=[result,VOID]}
            |   |       |           |                           |       |   |___methodDeclarator {id=2309,slot_type=methodDeclarator}
            |   |       |           |                           |       |       |___Token:run {id=2310,slot_type=Identifier}
            |   |       |           |                           |       |       |___Token:( {id=2311,slot_type=LPAREN}
            |   |       |           |                           |       |       |___Token:) {id=2312,slot_type=RPAREN}
            |   |       |           |                           |       |___block {id=2268,slot_type=[methodBody,block]}
            |   |       |           |                           |           |___Token:{ {id=2269,slot_type=LBRACE}
            |   |       |           |                           |           |___(?) {id=2270,slot_type=optional__block_1}
            |   |       |           |                           |           |   |___(+) {id=2272,slot_type=blockStatements}
            |   |       |           |                           |           |       |___expressionStatement {id=2276,slot_type=[blockStatement,statement,statementWithoutTrailingSubstatement,expressionStatement]}
            |   |       |           |                           |           |           |___methodInvocation {id=2279,slot_type=[statementExpression,methodInvocation]}
            |   |       |           |                           |           |           |   |___aux_rule__methodInvocation_19 {id=2282,slot_type=[altnt_block__methodInvocation_12,aux_rule__methodInvocation_19]}
            |   |       |           |                           |           |           |   |   |___Token:invokeAll {id=2307,slot_type=[altnt_block__methodInvocation_16,methodName,Identifier]}
            |   |       |           |                           |           |           |   |   |___Token:( {id=2284,slot_type=LPAREN}
            |   |       |           |                           |           |           |   |   |___(?) {id=2285,slot_type=optional__explicitConstructorInvocation_2}
            |   |       |           |                           |           |           |   |       |___Token:flushInterval {id=2305,slot_type=[argumentList,expression,conditionalExpression,conditionalOrExpression,conditionalAndExpression,inclusiveOrExpression,exclusiveOrExpression,andExpression,equalityExpression,relationalExpression,shiftExpression,additiveExpression,multiplicativeExpression,unaryExpression,aux_rule__unaryExpression_3,unaryExpressionNotPlusMinus,postfixExpression,altnt_block__postfixExpression_3,typeName,Identifier]}
            |   |       |           |                           |           |           |   |___Token:) {id=2281,slot_type=RPAREN}
            |   |       |           |                           |           |           |___Token:; {id=2278,slot_type=SEMI}
            |   |       |           |                           |           |___Token:} {id=2271,slot_type=RBRACE}
            |   |       |           |                           |___Token:} {id=2262,slot_type=RBRACE}
            |   |       |           |___Token:; {id=2226,slot_type=SEMI}
            |   |       |___Token:} {id=2221,slot_type=RBRACE}
            |   |___methodDeclaration {id=2193,slot_type=[classBodyDeclaration,methodDeclaration]}
            |       |___methodHeader {id=2194,slot_type=methodHeader}
            |       |   |___Token:void {id=2214,slot_type=[result,VOID]}
            |       |   |___methodDeclarator {id=2200,slot_type=methodDeclarator}
            |       |       |___Token:invokeAll {id=2201,slot_type=Identifier}
            |       |       |___Token:( {id=2202,slot_type=LPAREN}
            |       |       |___(?) {id=2203,slot_type=optional__methodDeclarator_1}
            |       |       |   |___formalParameter {id=2208,slot_type=[formalParameterList,aux_rule__formalParameterList_3,lastFormalParameter,formalParameter]}
            |       |       |       |___Token:int {id=2213,slot_type=[unannType,altnt_block__primitiveType_3,INT]}
            |       |       |       |___Token:flushInterval {id=2211,slot_type=[variableDeclaratorId,Identifier]}
            |       |       |___Token:) {id=2204,slot_type=RPAREN}
            |       |___block {id=2196,slot_type=[methodBody,block]}
            |           |___Token:{ {id=2197,slot_type=LBRACE}
            |           |___Token:} {id=2198,slot_type=RBRACE}
            |___Token:} {id=2190,slot_type=RBRACE}
------------------------------------------------------------


================Reducing node 2181, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_3]dd@1
    --file: Test.java--
    import java.util.TimerTask;
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2181
------------------------------------------------------------


================Reducing node 2184, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=2184}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2184
------------------------------------------------------------


================Reducing node 2187, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2187
------------------------------------------------------------


================Reducing node 2189, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@2
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@1
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@1
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2189
------------------------------------------------------------


================Reducing node 2215, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=2215}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                                                                      {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                                                                      {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2215
------------------------------------------------------------


================Reducing node 2218, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2218
------------------------------------------------------------


================Reducing node 2220, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__block_1]dd@1
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2220
------------------------------------------------------------


================Reducing node 2222, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=2222}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2222
------------------------------------------------------------


================Reducing node 2224, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2224
------------------------------------------------------------


================Reducing node 2225, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2225
------------------------------------------------------------


================Reducing node 2229, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t
                     ;
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t
                     ;
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask         TimerTask
                     ;
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask         TimerTask
                     ;
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2229
------------------------------------------------------------


================Reducing node 2231, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__variableDeclarator_2]dd@1
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t
                     ;
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t
                     ;
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2231
------------------------------------------------------------


================Reducing node 2232, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=2232}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2232
------------------------------------------------------------


================Reducing node 2254, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t =     TimerTask
                     ;
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t =     TimerTask
                     ;
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2254
------------------------------------------------------------


================Reducing node 2258, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__enumConstant_5]dd@1
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask()
                     ;
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask()
                     ;
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2258
------------------------------------------------------------


================Reducing node 2259, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=2259}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2259
------------------------------------------------------------


================Reducing node 2261, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__classBody_1]dd@1
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2261
------------------------------------------------------------


================Reducing node 2264, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=2264}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                                          {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                                          {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2264
------------------------------------------------------------


================Reducing node 2193, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=2193}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                                                   {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                                                   {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2193
------------------------------------------------------------


================Reducing node 2268, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2268
------------------------------------------------------------


================Reducing node 2180, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__compilationUnit_2]dd@1
    --file: Test.java--
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2180
------------------------------------------------------------


================Reducing node 2341, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=2341}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2341
------------------------------------------------------------


================Reducing node 2216, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2216
------------------------------------------------------------


================Reducing node 2194, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2194
------------------------------------------------------------


================Reducing node 2343, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import           TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import           TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java               ;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java               ;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2343
------------------------------------------------------------


================Reducing node 2325, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2325
------------------------------------------------------------


================Reducing node 2270, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__block_1]dd@1
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2270
------------------------------------------------------------


================Reducing node 2272, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=2272}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2272
------------------------------------------------------------


================Reducing node 2276, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2276
------------------------------------------------------------


================Reducing node 2200, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2200
------------------------------------------------------------


================Reducing node 2345, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__typeName_2]dd@1
    --file: Test.java--
    import           TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import           TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2345
------------------------------------------------------------


================Reducing node 2347, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=2347}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2347
------------------------------------------------------------


================Reducing node 2279, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2279
------------------------------------------------------------


================Reducing node 2266, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2266
------------------------------------------------------------


================Reducing node 2348, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import java     .TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java     .TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    --file: Test.java--
    import      util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import      util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2348
------------------------------------------------------------


================Reducing node 2309, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2309
------------------------------------------------------------


================Reducing node 2282, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2282
------------------------------------------------------------


================Reducing node 2351, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__packageName_1]dd@1
    --file: Test.java--
    import java     .TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java     .TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2351
------------------------------------------------------------


================Reducing node 2352, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=2352}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2352
------------------------------------------------------------


================Reducing node 2328, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__methodDeclarator_1]dd@1
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                                         ) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                                         ) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2328
------------------------------------------------------------


================Reducing node 2333, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=2333}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2333
------------------------------------------------------------


================Reducing node 2316, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2316
------------------------------------------------------------


================Reducing node 2203, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__methodDeclarator_1]dd@1
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(                 ) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(                 ) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2203
------------------------------------------------------------


================Reducing node 2208, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=2208}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2208
------------------------------------------------------------


================Reducing node 2196, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2196
------------------------------------------------------------


================Reducing node 2354, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2354
------------------------------------------------------------


================Reducing node 2353, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2353
------------------------------------------------------------


================Reducing node 2350, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2350
------------------------------------------------------------


================Reducing node 2349, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2349
------------------------------------------------------------


================Reducing node 2346, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2346
------------------------------------------------------------


================Reducing node 2344, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2344
------------------------------------------------------------


================Reducing node 2342, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2342
------------------------------------------------------------


================Reducing node 2339, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2339
------------------------------------------------------------


================Reducing node 2338, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2338
------------------------------------------------------------


================Reducing node 2336, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2336
------------------------------------------------------------


================Reducing node 2329, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2329
------------------------------------------------------------


================Reducing node 2327, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2327
------------------------------------------------------------


================Reducing node 2326, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2326
------------------------------------------------------------


================Reducing node 2323, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2323
------------------------------------------------------------


================Reducing node 2319, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2319
------------------------------------------------------------


================Reducing node 2318, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2318
------------------------------------------------------------


================Reducing node 2317, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2317
------------------------------------------------------------


================Reducing node 2313, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2313
------------------------------------------------------------


================Reducing node 2312, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2312
------------------------------------------------------------


================Reducing node 2311, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2311
------------------------------------------------------------


================Reducing node 2310, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2310
------------------------------------------------------------


================Reducing node 2307, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2307
------------------------------------------------------------


================Reducing node 2285, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:optional__explicitConstructorInvocation_2]dd@1
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(             );
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(             );
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2285
------------------------------------------------------------


================Reducing node 2305, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2305
------------------------------------------------------------


================Reducing node 2284, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2284
------------------------------------------------------------


================Reducing node 2281, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2281
------------------------------------------------------------


================Reducing node 2278, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2278
------------------------------------------------------------


================Reducing node 2271, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2271
------------------------------------------------------------


================Reducing node 2269, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2269
------------------------------------------------------------


================Reducing node 2265, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star:kleene_star__methodDeclaration_1]dd@1
    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                               void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
    --file: <formatted tokenized program in its original format>--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                               void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2265
------------------------------------------------------------


================Reducing node 2315, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2315
------------------------------------------------------------


================Reducing node 2262, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2262
------------------------------------------------------------


================Reducing node 2260, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2260
------------------------------------------------------------


================Reducing node 2257, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2257
------------------------------------------------------------


================Reducing node 2256, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2256
------------------------------------------------------------


================Reducing node 2233, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2233
------------------------------------------------------------


================Reducing node 2226, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2226
------------------------------------------------------------


================Reducing node 2221, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2221
------------------------------------------------------------


================Reducing node 2219, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2219
------------------------------------------------------------


================Reducing node 2214, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2214
------------------------------------------------------------


================Reducing node 2213, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2213
------------------------------------------------------------


================Reducing node 2211, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2211
------------------------------------------------------------


================Reducing node 2204, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2204
------------------------------------------------------------


================Reducing node 2202, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2202
------------------------------------------------------------


================Reducing node 2201, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2201
------------------------------------------------------------


================Reducing node 2198, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2198
------------------------------------------------------------


================Reducing node 2197, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2197
------------------------------------------------------------


================Reducing node 2190, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2190
------------------------------------------------------------


================Reducing node 2188, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2188
------------------------------------------------------------


================Reducing node 2186, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2186
------------------------------------------------------------


================Reducing node 2185, size=49=================

The current best program is the following

    --file: Test.java--
    import java.util.TimerTask;
           class Test {
                                void start(                       long flushInterval) {
                    TimerTask t = new TimerTask() {
                        public void run() {
                            invokeAll(flushInterval);
                        }
                    };
            }
                                 void invokeAll(int flushInterval) {
            }
    }
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2185
------------------------------------------------------------


The history of the reducer invocation.
[0]: StatsSnapshotEvent
---
stats:
  tokenCount: 462
  characterCount: 1830
  fileContents:
  - fileName: "Test.java"
    contentDigest:
      digest: {}
      numOfStrings: 1
numberOfNonDeletionIterations: 0
fileContentChangedWrtPrevious: false

[1]: ReducerCallEvent
---
reducer:
  shortName: "perses_node_priority_with_dfs_delta"
  description: ""
  deterministic: true
  reductionResultSizeTrend: "BEST_RESULT_SIZE_DECREASE"

[2]: StatsSnapshotEvent
---
stats:
  tokenCount: 69
  characterCount: 234
  fileContents:
  - fileName: "Test.java"
    contentDigest:
      digest: {}
      numOfStrings: 1
numberOfNonDeletionIterations: 0
fileContentChangedWrtPrevious: true

[3]: ReducerCallEvent
---
reducer:
  shortName: "perses_node_priority_with_dfs_delta"
  description: ""
  deterministic: true
  reductionResultSizeTrend: "BEST_RESULT_SIZE_DECREASE"

[4]: StatsSnapshotEvent
---
stats:
  tokenCount: 49
  characterCount: 170
  fileContents:
  - fileName: "Test.java"
    contentDigest:
      digest: {}
      numOfStrings: 1
numberOfNonDeletionIterations: 0
fileContentChangedWrtPrevious: true

[5]: ReducerCallEvent
---
reducer:
  shortName: "perses_node_priority_with_dfs_delta"
  description: ""
  deterministic: true
  reductionResultSizeTrend: "BEST_RESULT_SIZE_DECREASE"

[6]: StatsSnapshotEvent
---
stats:
  tokenCount: 49
  characterCount: 170
  fileContents:
  - fileName: "Test.java"
    contentDigest:
      digest: {}
      numOfStrings: 1
numberOfNonDeletionIterations: 0
fileContentChangedWrtPrevious: false


#test success = 36
#test failure = 171
#test result cache hits = 0
#test execution cancelled = 3
#node edit action set cache hits = 37
#external test execution cache hits = 0
